<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor Vial Profesional</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #151515; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; outline: none; }
        
        .panel {
            position: absolute;
            background: rgba(25, 25, 25, 0.95);
            backdrop-filter: blur(12px);
            border: 1px solid #444;
            color: #eee;
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            pointer-events: auto;
        }
        
        .toolbar { top: 20px; left: 20px; width: 280px; }
        .properties { top: 20px; right: 20px; width: 280px; display: none; }
        
        button {
            width: 100%; padding: 12px; margin-bottom: 8px;
            background: #2a2a2a; border: 1px solid #444; color: #ccc;
            border-radius: 6px; font-weight: 600; font-size: 11px; letter-spacing: 0.5px;
            cursor: pointer; transition: all 0.2s; text-transform: uppercase;
            display: flex; align-items: center; justify-content: center; gap: 8px;
        }
        button:hover { background: #3a3a3a; border-color: #60a5fa; color: white; }
        button.btn-special { background: #4f46e5; border-color: #4338ca; color: white; }
        button.btn-special:hover { background: #4338ca; box-shadow: 0 0 15px rgba(79, 70, 229, 0.4); }
        button.btn-alt { background: #0891b2; border-color: #0e7490; color: white; }
        button.btn-alt:hover { background: #0e7490; box-shadow: 0 0 15px rgba(8, 145, 178, 0.4); }
        button.btn-danger { background: #450a0a; border-color: #7f1d1d; color: #fca5a5; margin-top: 16px;}
        button.btn-danger:hover { background: #7f1d1d; color: white; }

        .control-group { margin-bottom: 12px; background: #222; padding: 10px; border-radius: 6px; border: 1px solid #333; }
        input[type=range] { width: 100%; accent-color: #3b82f6; margin: 10px 0 4px 0; cursor: pointer; }
        label { font-size: 10px; text-transform: uppercase; color: #888; display: flex; justify-content: space-between; letter-spacing: 1px; }
        .val { color: #60a5fa; font-family: monospace; font-size: 11px; }

        .snap-badge {
            position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%);
            background: #059669; color: white; padding: 8px 20px; border-radius: 30px;
            font-weight: bold; font-size: 13px; opacity: 0; transition: opacity 0.2s;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4); pointer-events: none;
            display: flex; align-items: center; gap: 8px; border: 1px solid #34d399;
        }
        .stats-box { margin-top: 15px; border-top: 1px solid #333; padding-top: 12px; font-size: 10px; color: #666; line-height: 1.5; }
    </style>
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
      }
    }
    </script>
</head>
<body>

    <div class="panel toolbar">
        <h2 class="text-xs font-bold text-blue-400 uppercase mb-4 border-b border-gray-700 pb-2 tracking-wider">Herramientas</h2>
        
        <button onclick="editor.addRoundabout()" class="btn-special">
            <span>◎</span> Estructura Base (Opción 1)
        </button>
        <button onclick="editor.addRadialHub()" class="btn-alt">
            <span>☀</span> Distribuidor Radial (Opción 2)
        </button>
        <button onclick="editor.generateMasterShape()">
            <span>★</span> Generar Circuito Oval
        </button>

        <div class="h-px bg-gray-700 my-4"></div>
        
        <button onclick="editor.addStraight()"><span>┃</span> Añadir Recta</button>
        <button onclick="editor.addCurve()"><span>C</span> Añadir Codo 90°</button>
        <button onclick="editor.exportDXF()">⬇ Exportar DXF</button>

        <div class="stats-box">
            • <strong>Opción 1:</strong> Anillo limpio de 310m.<br>
            • <strong>Opción 2:</strong> Anillo con 8 conexiones activas.<br>
            • <strong>Snap:</strong> Funciona en los 8 puertos radiales.
        </div>
    </div>

    <div class="panel properties" id="propPanel">
        <h2 class="text-xs font-bold text-green-400 uppercase mb-4 border-b border-gray-700 pb-2 tracking-wider">Editar Pieza</h2>
        
        <!-- Control Recta -->
        <div id="controls-straight" class="control-group">
            <label>Longitud <span id="lblLen" class="val">100m</span></label>
            <input type="range" id="rngLen" min="10" max="2000" step="10">
        </div>

        <!-- Control Curva / Rotonda -->
        <div id="controls-curve" class="control-group" style="display:none;">
            <label>Radio Eje <span id="lblRad" class="val">50m</span></label>
            <input type="range" id="rngRad" min="10" max="1000" step="5">
        </div>

        <!-- Rotación Común -->
        <div class="control-group">
            <label>Rotación <span id="lblRot" class="val">0°</span></label>
            <input type="range" id="rngRot" min="0" max="360" step="5">
        </div>

        <button onclick="editor.deleteSelected()" class="btn-danger">Eliminar</button>
    </div>

    <div id="snapMsg" class="snap-badge">
        <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>
        SNAP CONECTADO
    </div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    class RoadEditor {
        constructor() {
            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0x151515);
            
            this.camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 20000);
            this.camera.position.set(0, 1000, 1000); 

            this.renderer = new THREE.WebGLRenderer({ antialias: true });
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(this.renderer.domElement);

            this.controls = new OrbitControls(this.camera, this.renderer.domElement);
            this.controls.enableDamping = true;
            this.controls.dampingFactor = 0.05;

            const amb = new THREE.AmbientLight(0xffffff, 0.6);
            this.scene.add(amb);
            const dir = new THREE.DirectionalLight(0xffffff, 1);
            dir.position.set(500, 1000, 500);
            dir.castShadow = true;
            dir.shadow.mapSize.width = 4096;
            dir.shadow.mapSize.height = 4096;
            dir.shadow.camera.left = -2000; dir.shadow.camera.right = 2000;
            dir.shadow.camera.top = 2000; dir.shadow.camera.bottom = -2000;
            this.scene.add(dir);

            const grid = new THREE.GridHelper(10000, 500, 0x333333, 0x111111);
            this.scene.add(grid);
            this.plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

            this.matRoad = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
            this.matGrass = new THREE.MeshStandardMaterial({ color: 0x1a472a, roughness: 1 });
            this.matLines = new THREE.MeshBasicMaterial({ color: 0xffffff });
            this.matSel = new THREE.MeshStandardMaterial({ color: 0x3b82f6, emissive: 0x1e3a8a, emissiveIntensity: 0.5 });

            this.objects = [];
            this.selected = null;
            this.isDragging = false;
            this.raycaster = new THREE.Raycaster();
            this.mouse = new THREE.Vector2();
            this.dragOffset = new THREE.Vector3();

            window.addEventListener('resize', () => this.onResize());
            this.renderer.domElement.addEventListener('mousedown', (e) => this.onDown(e));
            this.renderer.domElement.addEventListener('mousemove', (e) => this.onMove(e));
            window.addEventListener('mouseup', () => this.onUp());
            
            document.getElementById('rngLen').addEventListener('input', (e) => this.setLength(e.target.value));
            document.getElementById('rngRad').addEventListener('input', (e) => this.setRadius(e.target.value));
            document.getElementById('rngRot').addEventListener('input', (e) => this.setRotation(e.target.value));

            this.animate();
        }

        // --- OPCIÓN 2: DISTRIBUIDOR RADIAL ---
        addRadialHub() {
            // 1. Limpiar o no? Mejor crear en centro.
            // Si el usuario quiere borrar todo, puede usar Master Shape o borrar manual.
            // Crearemos el hub en (0,0,0)
            
            // Crear Rotonda Base
            const hub = this.createRoundaboutObj(155, 10);
            hub.position.set(0,0,0);
            this.scene.add(hub); this.objects.push(hub);

            // Obtener conectores de la rotonda
            const connectors = this.getConnectors(hub);

            // Crear 8 rectas conectadas
            connectors.forEach((conn, index) => {
                const len = 150; // Longitud de los brazos
                const road = this.createStraight(len);
                
                // Posicionar para conectar
                // El conector de la rotonda es un punto y una dirección (hacia afuera).
                // El conector de la carretera recta tiene Frente (-Z) y Atrás (+Z).
                // Queremos que el "Atrás" de la recta conecte con la rotonda, y el "Frente" apunte afuera.
                // O viceversa.
                // Connector 'Straight' tiene dir (0,0,1) en Atrás.
                // Queremos alinear (Road Back) con (Hub Port).
                // Road Back Pos = (0,0,h). Road Back Dir = (0,0,1).
                // Target Pos = conn.pos. Target Dir = conn.dir.
                // Alinear: Road.pos = Target Pos - (LocalBackPos rotado).
                // Road.rot = Atan2(TargetDir) ...?
                // Simplemente: La recta debe rotarse igual que el angulo del conector de la rotonda.
                // Angulo del conector rotonda: index * 45 deg.
                
                const angle = (index * 45) * (Math.PI/180);
                road.rotation.y = angle;
                
                // Calcular posición
                // El centro de la recta debe estar desplazado del centro de la rotonda
                // Distancia = Radio Rotonda + (Longitud Recta / 2)
                const dist = 155 + (len / 2); // 155 es radio eje rotonda.
                // Nota: Queremos conectar el borde.
                // getConnectors devuelve la posición en el radio R (155).
                // Si alineamos road, su centro estará a R + L/2.
                
                road.position.set(
                    Math.cos(angle) * dist,
                    0,
                    Math.sin(angle) * dist
                );

                this.scene.add(road);
                this.objects.push(road);
            });
            
            this.select(hub);
        }

        // --- FUNCIONES CORE ---

        addRoundabout() {
            const g = this.createRoundaboutObj(155, 10);
            g.position.set(0, 0, 0);
            this.scene.add(g); this.objects.push(g); this.select(g);
        }

        createRoundaboutObj(radius, width) {
            const g = new THREE.Group();
            g.userData = { type: 'roundabout', radius: radius, width: width }; 
            this.buildRoundabout(g);
            return g;
        }

        buildRoundabout(g) {
            g.children.forEach(c => { if(c.geometry) c.geometry.dispose(); });
            g.remove(...g.children);
            const { radius, width } = g.userData; 
            const islandRadius = radius - (width/2);

            // Isla
            const grassGeo = new THREE.CircleGeometry(islandRadius, 64);
            const grass = new THREE.Mesh(grassGeo, this.matGrass);
            grass.rotation.x = -Math.PI/2; grass.position.y = 0.02;
            g.add(grass);

            // Vía
            const roadGeo = new THREE.RingGeometry(radius - width/2, radius + width/2, 64);
            const mat = this.selected === g ? this.matSel : this.matRoad;
            const road = new THREE.Mesh(roadGeo, mat);
            road.rotation.x = -Math.PI/2; road.receiveShadow = true;
            g.add(road);

            // Línea
            const lGeo = new THREE.RingGeometry(radius - 0.2, radius + 0.2, 64);
            const line = new THREE.Mesh(lGeo, this.matLines);
            line.rotation.x = -Math.PI/2; line.position.y = 0.05;
            g.add(line);
        }

        generateMasterShape() {
            this.objects.forEach(o => this.scene.remove(o));
            this.objects = []; this.select(null);

            const R = 150; const TotalL = 500; const StraightL = TotalL - (R * 2);
            const lS = this.createStraight(StraightL); lS.position.set(-R, 0, 0);
            this.scene.add(lS); this.objects.push(lS);
            const rS = this.createStraight(StraightL); rS.position.set(R, 0, 0);
            this.scene.add(rS); this.objects.push(rS);
            const halfS = StraightL / 2;
            const topCenter = new THREE.Vector3(0, 0, -halfS);
            this.placeCurve(topCenter, 150, 225); this.placeCurve(topCenter, 150, 315);
            const botCenter = new THREE.Vector3(0, 0, halfS);
            this.placeCurve(botCenter, 150, 45); this.placeCurve(botCenter, 150, 135);
            this.camera.position.set(0, 700, 0); this.camera.lookAt(0,0,0);
        }

        placeCurve(pos, rad, rotDeg) {
            const c = this.createCurve(rad, 90); c.position.copy(pos);
            c.rotation.y = rotDeg * (Math.PI/180); this.scene.add(c); this.objects.push(c);
        }

        addStraight() {
            const s = this.createStraight(100); s.position.set(Math.random()*50, 0, Math.random()*50);
            this.scene.add(s); this.objects.push(s); this.select(s);
        }

        addCurve() {
            const c = this.createCurve(50, 90); c.position.set(Math.random()*50, 0, Math.random()*50);
            this.scene.add(c); this.objects.push(c); this.select(c);
        }

        createStraight(len) {
            const g = new THREE.Group(); g.userData = { type: 'straight', length: parseFloat(len), width: 14 };
            this.buildStraight(g); return g;
        }

        createCurve(rad, angle) {
            const g = new THREE.Group(); g.userData = { type: 'curve', radius: parseFloat(rad), angle: angle, width: 14 };
            this.buildCurve(g); return g;
        }

        buildStraight(g) {
            g.children.forEach(c => c.geometry.dispose()); g.remove(...g.children);
            const { length, width } = g.userData;
            const geo = new THREE.PlaneGeometry(width, length);
            const mat = this.selected === g ? this.matSel : this.matRoad;
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = -Math.PI/2; mesh.receiveShadow = true;
            g.add(mesh);
            const cnt = Math.floor(length/10);
            const lGeo = new THREE.PlaneGeometry(0.8, 4);
            const lines = new THREE.InstancedMesh(lGeo, this.matLines, cnt);
            lines.rotation.x = -Math.PI/2; lines.position.y = 0.05;
            const dummy = new THREE.Object3D();
            for(let i=0; i<cnt; i++) { dummy.position.set(0, (i - cnt/2 + 0.5)*10, 0); dummy.updateMatrix(); lines.setMatrixAt(i, dummy.matrix); }
            lines.instanceMatrix.needsUpdate = true; g.add(lines);
        }

        buildCurve(g) {
            g.children.forEach(c => { if(c.geometry) c.geometry.dispose(); }); g.remove(...g.children);
            const { radius, width, angle } = g.userData; const theta = angle * (Math.PI/180);
            const shape = new THREE.RingGeometry(radius - width/2, radius + width/2, 64, 1, -theta/2, theta);
            const mat = this.selected === g ? this.matSel : this.matRoad;
            const mesh = new THREE.Mesh(shape, mat);
            mesh.rotation.x = -Math.PI/2; mesh.receiveShadow = true; g.add(mesh);
            const lShape = new THREE.RingGeometry(radius - 0.2, radius + 0.2, 64, 1, -theta/2, theta);
            const line = new THREE.Mesh(lShape, this.matLines);
            line.rotation.x = -Math.PI/2; line.position.y = 0.05; g.add(line);
        }

        select(obj) {
            if(this.selected && this.selected !== obj) this.updateMat(this.selected, this.matRoad);
            this.selected = obj;
            const panel = document.getElementById('propPanel');
            const cStraight = document.getElementById('controls-straight');
            const cCurve = document.getElementById('controls-curve');

            if(obj) {
                this.updateMat(obj, this.matSel);
                panel.style.display = 'block';
                document.getElementById('rngRot').value = (Math.round(obj.rotation.y * 180/Math.PI)+360)%360;
                document.getElementById('lblRot').innerText = Math.round(obj.rotation.y * 180/Math.PI) + '°';

                if(obj.userData.type === 'straight') {
                    cStraight.style.display = 'block'; cCurve.style.display = 'none';
                    document.getElementById('rngLen').value = obj.userData.length;
                    document.getElementById('lblLen').innerText = Math.round(obj.userData.length)+'m';
                } else {
                    cStraight.style.display = 'none'; cCurve.style.display = 'block';
                    document.getElementById('rngRad').value = obj.userData.radius;
                    document.getElementById('lblRad').innerText = Math.round(obj.userData.radius)+'m';
                }
            } else { panel.style.display = 'none'; }
        }

        updateMat(obj, mat) {
            // Fix: roundabout logic
            if(obj.userData.type === 'roundabout') {
                // Child 0 is Grass, Child 1 is Road
                if(obj.children[1]) obj.children[1].material = mat; 
            } else {
                if(obj.children[0]) obj.children[0].material = mat;
            }
        }

        setLength(val) {
            if(this.selected && this.selected.userData.type === 'straight') {
                this.selected.userData.length = parseFloat(val);
                document.getElementById('lblLen').innerText = val+'m'; this.buildStraight(this.selected);
            }
        }
        setRadius(val) {
            if(this.selected) {
                this.selected.userData.radius = parseFloat(val);
                document.getElementById('lblRad').innerText = val+'m';
                if(this.selected.userData.type === 'roundabout') this.buildRoundabout(this.selected);
                else this.buildCurve(this.selected);
            }
        }
        setRotation(val) {
            if(this.selected) {
                this.selected.rotation.y = val * Math.PI/180;
                document.getElementById('lblRot').innerText = val+'°';
            }
        }
        deleteSelected() {
            if(this.selected) {
                this.scene.remove(this.selected);
                this.objects = this.objects.filter(o => o !== this.selected);
                this.select(null);
            }
        }

        getConnectors(obj) {
            const arr = []; obj.updateMatrixWorld(); const pos = obj.position; const rot = obj.rotation.y;
            if(obj.userData.type === 'straight') {
                const h = obj.userData.length / 2;
                arr.push({ pos: new THREE.Vector3(0,0,-h).applyAxisAngle(new THREE.Vector3(0,1,0), rot).add(pos), dir: new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), rot).normalize() });
                arr.push({ pos: new THREE.Vector3(0,0,h).applyAxisAngle(new THREE.Vector3(0,1,0), rot).add(pos), dir: new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), rot).normalize() });
            } else if (obj.userData.type === 'curve') {
                const R = obj.userData.radius; const halfA = (obj.userData.angle * Math.PI/180) / 2;
                const x1 = R * Math.cos(-halfA); const z1 = -R * Math.sin(-halfA);
                const t1x = Math.sin(-halfA); const t1z = Math.cos(-halfA);
                const p1 = new THREE.Vector3(x1, 0, z1).applyAxisAngle(new THREE.Vector3(0,1,0), rot).add(pos);
                const d1 = new THREE.Vector3(t1x, 0, t1z).applyAxisAngle(new THREE.Vector3(0,1,0), rot).normalize();
                arr.push({ pos: p1, dir: d1 });
                const x2 = R * Math.cos(halfA); const z2 = -R * Math.sin(halfA);
                const t2x = -Math.sin(halfA); const t2z = -Math.cos(halfA);
                const p2 = new THREE.Vector3(x2, 0, z2).applyAxisAngle(new THREE.Vector3(0,1,0), rot).add(pos);
                const d2 = new THREE.Vector3(t2x, 0, t2z).applyAxisAngle(new THREE.Vector3(0,1,0), rot).normalize();
                arr.push({ pos: p2, dir: d2 });
            } else if (obj.userData.type === 'roundabout') {
                const R = obj.userData.radius;
                for(let i=0; i<8; i++) {
                    const angle = (i * 45) * (Math.PI/180);
                    const lx = Math.cos(angle) * R; const lz = Math.sin(angle) * R;
                    const dx = Math.cos(angle); const dz = Math.sin(angle);
                    const p = new THREE.Vector3(lx, 0, lz).applyAxisAngle(new THREE.Vector3(0,1,0), rot).add(pos);
                    const d = new THREE.Vector3(dx, 0, dz).applyAxisAngle(new THREE.Vector3(0,1,0), rot).normalize();
                    arr.push({ pos: p, dir: d });
                }
            }
            return arr;
        }

        checkSnap() {
            if(!this.selected || !this.isDragging) return;
            const SNAP_DIST = 30; const myCons = this.getConnectors(this.selected); let snapped = false;
            for(let other of this.objects) {
                if(other === this.selected) continue;
                const otherCons = this.getConnectors(other);
                for(let myC of myCons) {
                    for(let otC of otherCons) {
                        if(myC.pos.distanceTo(otC.pos) < SNAP_DIST) {
                            const offset = new THREE.Vector3().subVectors(myC.pos, this.selected.position);
                            this.selected.position.subVectors(otC.pos, offset);
                            const targetAngle = Math.atan2(otC.dir.x, otC.dir.z) + Math.PI;
                            const currentAngle = Math.atan2(myC.dir.x, myC.dir.z);
                            let delta = targetAngle - currentAngle;
                            this.selected.rotation.y += delta;
                            snapped = true; break;
                        }
                    }
                    if(snapped) break;
                }
                if(snapped) break;
            }
            document.getElementById('snapMsg').style.opacity = snapped ? 1 : 0;
        }

        onDown(e) {
            if(e.button !== 0) return;
            this.mouse.x = (e.clientX/window.innerWidth)*2-1; this.mouse.y = -(e.clientY/window.innerHeight)*2+1;
            this.raycaster.setFromCamera(this.mouse, this.camera);
            const intersects = this.raycaster.intersectObjects(this.objects, true);
            if(intersects.length > 0) {
                let target = intersects[0].object; while(target.parent && target.parent.type !== 'Scene') target = target.parent;
                this.select(target); this.isDragging = true; this.controls.enabled = false;
                const p = new THREE.Vector3(); this.raycaster.ray.intersectPlane(this.plane, p);
                this.dragOffset.subVectors(target.position, p);
            } else { this.select(null); }
        }
        onMove(e) {
            if(this.isDragging && this.selected) {
                this.mouse.x = (e.clientX/window.innerWidth)*2-1; this.mouse.y = -(e.clientY/window.innerHeight)*2+1;
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const p = new THREE.Vector3();
                if(this.raycaster.ray.intersectPlane(this.plane, p)) {
                    this.selected.position.addVectors(p, this.dragOffset); this.checkSnap();
                }
            }
        }
        onUp() { this.isDragging = false; this.controls.enabled = true; document.getElementById('snapMsg').style.opacity = 0; }
        onResize() { this.camera.aspect = window.innerWidth/window.innerHeight; this.camera.updateProjectionMatrix(); this.renderer.setSize(window.innerWidth, window.innerHeight); }
        animate() { requestAnimationFrame(() => this.animate()); this.controls.update(); this.renderer.render(this.scene, this.camera); }

        exportDXF() {
            let s = "0\nSECTION\n2\nENTITIES\n";
            this.objects.forEach(o => {
                const p = o.position, r = o.rotation.y;
                if(o.userData.type === 'straight') {
                    const h = o.userData.length/2;
                    const x1 = p.x - Math.sin(r)*h, z1 = p.z - Math.cos(r)*h;
                    const x2 = p.x + Math.sin(r)*h, z2 = p.z + Math.cos(r)*h;
                    s+=`0\nLINE\n8\nRoad\n10\n${x1}\n20\n${z1}\n11\n${x2}\n21\n${z2}\n`;
                } else if(o.userData.type === 'roundabout') {
                    const R = o.userData.radius; s+=`0\nCIRCLE\n8\nRoundabout\n10\n${p.x}\n20\n${p.z}\n40\n${R}\n`;
                } else {
                    const R = o.userData.radius;
                    const startDeg = ((r * 180/Math.PI) - (o.userData.angle/2) - 90);
                    const endDeg = ((r * 180/Math.PI) + (o.userData.angle/2) - 90);
                    s+=`0\nARC\n8\nRoadCurve\n10\n${p.x}\n20\n${p.z}\n40\n${R}\n50\n${startDeg}\n51\n${endDeg}\n`;
                }
            });
            s+="0\nENDSEC\n0\nEOF";
            const b = new Blob([s],{type:'application/dxf'});
            const l = document.createElement('a'); l.href=URL.createObjectURL(b); l.download='road_layout.dxf'; l.click();
        }
    }

    window.editor = new RoadEditor();
</script>
</body>
</html>