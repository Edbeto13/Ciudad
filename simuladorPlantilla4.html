<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador Pir√°mides Octagonales - Escala 1:300</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #151515; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; outline: none; }
        
        .panel {
            position: absolute;
            background: rgba(25, 25, 25, 0.95);
            backdrop-filter: blur(12px);
            border: 1px solid #444;
            color: #eee;
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            pointer-events: auto;
        }
        
        .toolbar { top: 20px; left: 20px; width: 280px; }
        .properties { top: 20px; right: 20px; width: 280px; display: none; }
        
        button {
            width: 100%; padding: 12px; margin-bottom: 8px;
            background: #2a2a2a; border: 1px solid #444; color: #ccc;
            border-radius: 6px; font-weight: 600; font-size: 11px; letter-spacing: 0.5px;
            cursor: pointer; transition: all 0.2s; text-transform: uppercase;
            display: flex; align-items: center; justify-content: center; gap: 8px;
        }
        button:hover { background: #3a3a3a; border-color: #60a5fa; color: white; }
        button.btn-special { background: #4f46e5; border-color: #4338ca; color: white; }
        button.btn-special:hover { background: #4338ca; box-shadow: 0 0 15px rgba(79, 70, 229, 0.4); }
        button.btn-alt { background: #0891b2; border-color: #0e7490; color: white; }
        button.btn-alt:hover { background: #0e7490; box-shadow: 0 0 15px rgba(8, 145, 178, 0.4); }
        button.btn-danger { background: #450a0a; border-color: #7f1d1d; color: #fca5a5; margin-top: 16px;}
        button.btn-danger:hover { background: #7f1d1d; color: white; }

        .control-group { margin-bottom: 12px; background: #222; padding: 10px; border-radius: 6px; border: 1px solid #333; }
        input[type=range] { width: 100%; accent-color: #3b82f6; margin: 10px 0 4px 0; cursor: pointer; }
        label { font-size: 10px; text-transform: uppercase; color: #888; display: flex; justify-content: space-between; letter-spacing: 1px; }
        .val { color: #60a5fa; font-family: monospace; font-size: 11px; }

        .snap-badge {
            position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%);
            background: #059669; color: white; padding: 8px 20px; border-radius: 30px;
            font-weight: bold; font-size: 13px; opacity: 0; transition: opacity 0.2s;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4); pointer-events: none;
            display: flex; align-items: center; gap: 8px; border: 1px solid #34d399;
        }
        .stats-box { margin-top: 15px; border-top: 1px solid #333; padding-top: 12px; font-size: 10px; color: #666; line-height: 1.5; }
    </style>
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
      }
    }
    </script>
</head>
<body>

    <div class="panel toolbar">
        <h2 class="text-xs font-bold text-blue-400 uppercase mb-4 border-b border-gray-700 pb-2 tracking-wider">Pir√°mides 1:300</h2>
        
        <button onclick="editor.showBaseArea()" class="btn-alt">
            <span>‚ñ≠</span> Mostrar Base 210√ó150m
        </button>
        <button onclick="editor.addPyramid()" class="btn-special">
            <span>‚ñ≥</span> A√±adir Pir√°mide (6‚Üí2)
        </button>
        <button onclick="editor.generatePyramidGrid()">
            <span>‚ñ¶</span> Generar Grid 2√ó12 Pir√°mides
        </button>

        <div class="h-px bg-gray-700 my-4"></div>
        
        <button onclick="editor.addOctagon()">
            <span>‚¨°</span> M√≥dulo Octagonal 50m¬≤
        </button>
        <button onclick="editor.generatePerimeterRoad()" class="btn-alt">
            <span>‚ñ°</span> Carretera Perimetral
        </button>
        <button onclick="editor.addStraight()"><span>‚îÉ</span> A√±adir Recta</button>
        <button onclick="editor.addCurve()"><span>C</span> A√±adir Codo 90¬∞</button>
        <button onclick="editor.addParametricRoundabout()" class="btn-special">
            <span>‚óé</span> Glorieta Param√©trica
        </button>
        <button onclick="editor.addRadialHub()" class="btn-alt">
            <span>‚òÄ</span> Distribuidor Radial (8 brazos)
        </button>
        
        <div class="h-px bg-gray-700 my-4"></div>
        <div style="font-size:9px; color:#10b981; margin-bottom:6px; text-transform:uppercase; letter-spacing:1px;">üöó Veh√≠culos</div>
        <button onclick="editor.addCybertruck()" class="btn-special" style="background:#1a1a2e; border-color:#0f4c75;">
            <span>üöê</span> Tesla Cybertruck
        </button>
        <div style="font-size:8px; color:#666; margin-top:-4px; margin-bottom:8px; padding-left:4px;">
            WASD/Flechas: mover | Q/E: girar | Shift: turbo
        </div>
        
        <button onclick="editor.exportDXF()">‚¨á Exportar DXF</button>
        
        <div class="h-px bg-gray-700 my-4"></div>
        <div style="font-size:9px; color:#f59e0b; margin-bottom:6px; text-transform:uppercase; letter-spacing:1px;">üíæ Proyecto</div>
        <button onclick="editor.saveScene()" class="btn-alt" style="background:#065f46; border-color:#059669;">
            <span>üíæ</span> Guardar Escena
        </button>
        <button onclick="editor.loadSavedScene()" style="background:#1e3a5f; border-color:#3b82f6;">
            <span>üìÇ</span> Cargar Escena
        </button>
        <button onclick="editor.clearScene()" class="btn-danger" style="margin-top:4px;">
            <span>üóë</span> Limpiar Todo
        </button>

        <div class="stats-box">
            <strong>Escala 1:300</strong> | Base: 70√ó50cm<br>
            ‚Ä¢ <strong>Carretera:</strong> 4 rectas + 4 codos (R=37.5m) + glorieta central<br>
            ‚Ä¢ <strong>Oct√°gono:</strong> 50m¬≤, V-V: 2.8cm, C-C: 2.59cm<br>
            ‚Ä¢ <strong>Pir√°mide:</strong> 6‚Üí2 oct, 16.8√ó2.59cm<br>
            ‚Ä¢ <strong>Cybertruck:</strong> 5.68√ó2.03m (19√ó6.8mm)<br>
            ‚Ä¢ <strong>Radial:</strong> Glorieta R=50m + 8 brazos de 100m
        </div>
    </div>

    <div class="panel properties" id="propPanel">
        <h2 class="text-xs font-bold text-green-400 uppercase mb-4 border-b border-gray-700 pb-2 tracking-wider">Editar Pieza</h2>
        
        <!-- Control Recta -->
        <div id="controls-straight" class="control-group">
            <label>Longitud <span id="lblLen" class="val">100m</span></label>
            <input type="range" id="rngLen" min="10" max="2000" step="10">
        </div>

        <!-- Control Curva / Rotonda -->
        <div id="controls-curve" class="control-group" style="display:none;">
            <label>Radio Eje <span id="lblRad" class="val">50m</span></label>
            <input type="range" id="rngRad" min="10" max="1000" step="5">
        </div>

        <!-- Control Glorieta Param√©trica -->
        <div id="controls-roundabout" class="control-group" style="display:none;">
            <label>Di√°metro <span id="lblDiam" class="val">50m</span></label>
            <input type="range" id="rngDiam" min="10" max="200" step="1">
            <div id="lblArea" style="font-size:11px; color:#22c55e; margin-top:6px; font-weight:bold;">√Årea: -- m¬≤</div>
            <div style="font-size:9px; color:#666; margin-top:4px;">Ancho fijo: 10m | Rango: 10-200m</div>
        </div>

        <!-- Rotaci√≥n Com√∫n -->
        <div class="control-group">
            <label>Rotaci√≥n <span id="lblRot" class="val">0¬∞</span></label>
            <input type="range" id="rngRot" min="0" max="360" step="5">
        </div>

        <button onclick="editor.deleteSelected()" class="btn-danger">Eliminar</button>
    </div>

    <div id="snapMsg" class="snap-badge">
        <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>
        SNAP CONECTADO
    </div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    class RoadEditor {
        constructor() {
            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0x151515);
            
            this.camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 5000);
            this.camera.position.set(0, 200, 250); // Vista ajustada para escala 1:300 

            this.renderer = new THREE.WebGLRenderer({ antialias: true });
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(this.renderer.domElement);

            this.controls = new OrbitControls(this.camera, this.renderer.domElement);
            this.controls.enableDamping = true;
            this.controls.dampingFactor = 0.05;

            const amb = new THREE.AmbientLight(0xffffff, 0.6);
            this.scene.add(amb);
            const dir = new THREE.DirectionalLight(0xffffff, 1);
            dir.position.set(500, 1000, 500);
            dir.castShadow = true;
            dir.shadow.mapSize.width = 4096;
            dir.shadow.mapSize.height = 4096;
            dir.shadow.camera.left = -2000; dir.shadow.camera.right = 2000;
            dir.shadow.camera.top = 2000; dir.shadow.camera.bottom = -2000;
            this.scene.add(dir);

            const grid = new THREE.GridHelper(300, 30, 0x333333, 0x222222); // Grid 300m con 10m divisiones
            this.scene.add(grid);
            this.plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

            // === CONSTANTES ESCALA 1:300 ===
            this.SCALE = 300; // 1:300
            this.BASE_REAL_X = 210; // metros reales (70cm maqueta)
            this.BASE_REAL_Z = 150; // metros reales (50cm maqueta)
            this.OCT_AREA = 50;     // m¬≤ por oct√°gono
            this.OCT_HEIGHT = 3;    // altura m√≥dulo (3m real)
            // Oct√°gono 50m¬≤: Radio = sqrt(50 / (2*sqrt(2))) ‚âà 4.204m (V-V real)
            this.OCT_RADIUS = Math.sqrt(this.OCT_AREA / (2 * Math.sqrt(2))); // ~4.204m
            // Distancia cara a cara = Radio * cos(22.5¬∞) * 2 ‚âà 7.768m / 2 = 3.884m por lado
            this.OCT_FACE_DIST = this.OCT_RADIUS * Math.cos(Math.PI / 8) * 2; // ~7.768m

            // === CONSTANTES CYBERTRUCK (metros reales) ===
            this.CYBER = {
                LENGTH: 5.683,    // Longitud total en metros
                WIDTH: 2.032,     // Ancho sin espejos
                HEIGHT: 1.791,    // Altura (suspensi√≥n media)
                WHEELBASE: 3.635, // Distancia entre ejes
                GROUND_CLEARANCE: 0.35, // Despeje al suelo
                // F√≠sica de movimiento
                MAX_SPEED: 50,       // Velocidad m√°xima m/s (~180 km/h)
                ACCELERATION: 15,    // Aceleraci√≥n m/s¬≤ (0-100 en ~6.6s)
                BRAKE_FORCE: 25,     // Frenado m/s¬≤
                TURN_RATE: 2.5,      // Velocidad de giro rad/s
                FRICTION: 0.97,      // Coeficiente de fricci√≥n
                // Colores
                COLOR_BODY: 0xc0c0c0,   // Acero inoxidable
                COLOR_WINDOW: 0x1a1a2e, // Ventanas oscuras
                COLOR_LIGHT: 0xffffff,  // Luces
                COLOR_WHEEL: 0x222222   // Ruedas
            };

            this.matRoad = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
            this.matGrass = new THREE.MeshStandardMaterial({ color: 0x1a472a, roughness: 1 });
            this.matLines = new THREE.MeshBasicMaterial({ color: 0xffffff });
            this.matSel = new THREE.MeshStandardMaterial({ color: 0x3b82f6, emissive: 0x1e3a8a, emissiveIntensity: 0.5 });
            
            // Materiales para m√≥dulo octagonal
            this.matOctWall = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, roughness: 0.7, metalness: 0.1 });
            this.matOctCap = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 });
            this.matOctVertex = new THREE.MeshBasicMaterial({ color: 0xffcc00 });
            this.matOctHighlight = new THREE.MeshBasicMaterial({ color: 0x0078d4, wireframe: true, transparent: true, opacity: 0.3 });
            
            // Materiales para Cybertruck
            this.matCyberBody = new THREE.MeshStandardMaterial({ 
                color: this.CYBER.COLOR_BODY, 
                roughness: 0.2, 
                metalness: 0.9,
                envMapIntensity: 1.0
            });
            this.matCyberWindow = new THREE.MeshStandardMaterial({ 
                color: this.CYBER.COLOR_WINDOW, 
                roughness: 0.1, 
                metalness: 0.5,
                transparent: true,
                opacity: 0.8
            });
            this.matCyberWheel = new THREE.MeshStandardMaterial({ 
                color: this.CYBER.COLOR_WHEEL, 
                roughness: 0.6, 
                metalness: 0.3
            });
            this.matCyberLight = new THREE.MeshBasicMaterial({ 
                color: this.CYBER.COLOR_LIGHT
            });
            this.matCyberTailLight = new THREE.MeshBasicMaterial({ 
                color: 0xff3333
            });
            
            // Estado de veh√≠culos activos
            this.vehicles = [];
            this.activeVehicle = null; // Veh√≠culo actualmente controlado
            this.vehicleKeys = {
                forward: false,
                backward: false,
                left: false,
                right: false,
                turbo: false
            };
            
            // Texturas para etiquetas num√©ricas del oct√°gono
            this.octTextures = this.createNumberTextures();

            this.objects = [];
            this.selected = null;
            this.isDragging = false;
            this.raycaster = new THREE.Raycaster();
            this.mouse = new THREE.Vector2();
            this.dragOffset = new THREE.Vector3();
            
            // Sistema de resize handles (estilo Word)
            this.resizeHandles = [];
            this.isResizing = false;
            this.activeHandle = null;
            this.resizeStartPos = new THREE.Vector3();
            this.resizeStartLength = 0;
            
            // Material para handles de resize
            this.matHandle = new THREE.MeshBasicMaterial({ color: 0x00aaff });
            this.matHandleHover = new THREE.MeshBasicMaterial({ color: 0xffff00 });

            window.addEventListener('resize', () => this.onResize());
            this.renderer.domElement.addEventListener('mousedown', (e) => this.onDown(e));
            this.renderer.domElement.addEventListener('mousemove', (e) => this.onMove(e));
            window.addEventListener('mouseup', () => this.onUp());
            
            document.getElementById('rngLen').addEventListener('input', (e) => this.setLength(e.target.value));
            document.getElementById('rngRad').addEventListener('input', (e) => this.setRadius(e.target.value));
            document.getElementById('rngRot').addEventListener('input', (e) => this.setRotation(e.target.value));
            document.getElementById('rngDiam').addEventListener('input', (e) => this.setDiameter(e.target.value));

            // Controles de teclado
            window.addEventListener('keydown', (e) => this.onKeyDown(e));
            window.addEventListener('keyup', (e) => this.onKeyUp(e));
            
            // Reloj para delta time (f√≠sica)
            this.clock = new THREE.Clock();

            // Cargar escena predeterminada
            this.loadDefaultScene();

            this.animate();
        }

        // === ESCENA PREDETERMINADA ===
        // Basada en escena_ciudad_2025-12-28.json construida manualmente
        loadDefaultScene() {
            // Mostrar base
            this.showBaseArea();
            
            // Glorieta central (radio 40m, ancho 10m)
            const roundabout = this.createRoundaboutObj(40, 10);
            roundabout.position.set(0, 0, 0);
            this.scene.add(roundabout);
            this.objects.push(roundabout);
            
            // Carretera vertical superior (180m) - horizontal en pantalla
            const roadTop = this.createStraight(180);
            roadTop.position.set(-0.33, 0, -69.84);
            roadTop.rotation.y = Math.PI / 2;
            this.scene.add(roadTop);
            this.objects.push(roadTop);
            
            // Carretera vertical inferior (180m) - horizontal en pantalla
            const roadBottom = this.createStraight(180);
            roadBottom.position.set(-0.19, 0, 69.84);
            roadBottom.rotation.y = Math.PI / 2;
            this.scene.add(roadBottom);
            this.objects.push(roadBottom);
            
            // Carretera horizontal izquierda (120m) - vertical en pantalla
            const roadLeft = this.createStraight(120);
            roadLeft.position.set(-100.33, 0, 0.16);
            roadLeft.rotation.y = Math.PI;
            this.scene.add(roadLeft);
            this.objects.push(roadLeft);
            
            // Carretera horizontal derecha (120m) - vertical en pantalla
            const roadRight = this.createStraight(120);
            roadRight.position.set(99.67, 0, 0.16);
            roadRight.rotation.y = Math.PI;
            this.scene.add(roadRight);
            this.objects.push(roadRight);
            
            // Brazo diagonal sureste (40m)
            const armSE = this.createStraight(40);
            armSE.position.set(45.96, 0, 45.96);
            armSE.rotation.y = Math.PI / 4; // 45¬∞
            this.scene.add(armSE);
            this.objects.push(armSE);
            
            // Brazo diagonal noreste (40m)
            const armNE = this.createStraight(40);
            armNE.position.set(45.96, 0, -45.96);
            armNE.rotation.y = -Math.PI / 4; // -45¬∞
            this.scene.add(armNE);
            this.objects.push(armNE);
            
            // Brazo diagonal noroeste (40m)
            const armNW = this.createStraight(40);
            armNW.position.set(-45.96, 0, -45.96);
            armNW.rotation.y = Math.PI * 5 / 4; // 225¬∞
            this.scene.add(armNW);
            this.objects.push(armNW);
            
            // Brazo diagonal suroeste (40m)
            const armSW = this.createStraight(40);
            armSW.position.set(-45.96, 0, 45.96);
            armSW.rotation.y = Math.PI * 7 / 4; // 315¬∞
            this.scene.add(armSW);
            this.objects.push(armSW);
            
            // Curva esquina noroeste
            const curveNW = this.createCurve(10, 90);
            curveNW.position.set(-90.33, 0, -59.84);
            curveNW.rotation.y = Math.PI * 3 / 4; // 135¬∞
            this.scene.add(curveNW);
            this.objects.push(curveNW);
            
            // Curva esquina noreste
            const curveNE = this.createCurve(10, 90);
            curveNE.position.set(89.67, 0, -59.84);
            curveNE.rotation.y = Math.PI / 4; // 45¬∞
            this.scene.add(curveNE);
            this.objects.push(curveNE);
            
            // Curva esquina suroeste
            const curveSW = this.createCurve(10, 90);
            curveSW.position.set(-90.19, 0, 59.84);
            curveSW.rotation.y = -Math.PI * 3 / 4; // -135¬∞
            this.scene.add(curveSW);
            this.objects.push(curveSW);
            
            // Curva esquina sureste
            const curveSE = this.createCurve(10, 90);
            curveSE.position.set(89.81, 0, 59.84);
            curveSE.rotation.y = -Math.PI / 4; // -45¬∞
            this.scene.add(curveSE);
            this.objects.push(curveSE);
            
            // Conexi√≥n glorieta-derecha (50m)
            const connRight = this.createStraight(50);
            connRight.position.set(70, 0, 0);
            connRight.rotation.y = Math.PI / 2; // 90¬∞
            this.scene.add(connRight);
            this.objects.push(connRight);
            
            // Conexi√≥n glorieta-izquierda (50m)
            const connLeft = this.createStraight(50);
            connLeft.position.set(-70, 0, 0);
            connLeft.rotation.y = Math.PI / 2; // 90¬∞
            this.scene.add(connLeft);
            this.objects.push(connLeft);
            
            // Ajustar c√°mara para ver toda la escena (vista cenital)
            this.camera.position.set(8.39, 252.39, -0.40);
            this.controls.target.set(8.39, 0, -0.40);
        }
        
        // === GUARDAR / CARGAR ESCENA ===
        saveScene() {
            const sceneData = this.serializeScene();
            localStorage.setItem('ciudadEla_scene', JSON.stringify(sceneData));
            
            // Tambi√©n ofrecer descarga como archivo
            const blob = new Blob([JSON.stringify(sceneData, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'escena_ciudad_' + new Date().toISOString().slice(0,10) + '.json';
            a.click();
            URL.revokeObjectURL(url);
            
            alert('‚úÖ Escena guardada!\n‚Ä¢ En localStorage (se carga autom√°ticamente)\n‚Ä¢ Archivo JSON descargado');
        }
        
        loadSavedScene() {
            // Primero intentar cargar de localStorage
            const saved = localStorage.getItem('ciudadEla_scene');
            if(saved) {
                if(confirm('¬øCargar escena guardada de localStorage?\n(Cancelar para cargar desde archivo)')) {
                    this.deserializeScene(JSON.parse(saved));
                    return;
                }
            }
            
            // Cargar desde archivo
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if(!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        const data = JSON.parse(ev.target.result);
                        this.deserializeScene(data);
                        alert('‚úÖ Escena cargada correctamente');
                    } catch(err) {
                        alert('‚ùå Error al cargar: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }
        
        clearScene() {
            if(!confirm('¬øSeguro que deseas eliminar TODOS los elementos?')) return;
            this.objects.forEach(o => this.scene.remove(o));
            this.objects = [];
            this.select(null);
            this.resizeHandles = [];
        }
        
        serializeScene() {
            return {
                version: '1.0',
                date: new Date().toISOString(),
                camera: {
                    position: { x: this.camera.position.x, y: this.camera.position.y, z: this.camera.position.z },
                    target: { x: this.controls.target.x, y: this.controls.target.y, z: this.controls.target.z }
                },
                objects: this.objects.map(o => {
                    const data = {
                        type: o.userData.type,
                        position: { x: o.position.x, y: o.position.y, z: o.position.z },
                        rotation: o.rotation.y
                    };
                    
                    // Propiedades espec√≠ficas por tipo
                    switch(o.userData.type) {
                        case 'straight':
                            data.length = o.userData.length;
                            data.width = o.userData.width;
                            break;
                        case 'curve':
                            data.radius = o.userData.radius;
                            data.angle = o.userData.angle;
                            data.width = o.userData.width;
                            break;
                        case 'roundabout':
                            data.radius = o.userData.radius;
                            data.width = o.userData.width;
                            break;
                        case 'parametricRoundabout':
                            data.diametro = o.userData.diametro;
                            data.ancho = o.userData.ancho;
                            break;
                        case 'octagon':
                            data.area = o.userData.area;
                            data.height = o.userData.height;
                            break;
                        case 'pyramid':
                            data.levels = o.userData.levels;
                            break;
                        case 'cybertruck':
                            data.velocity = o.userData.velocity || 0;
                            break;
                    }
                    return data;
                })
            };
        }
        
        deserializeScene(data) {
            // Limpiar escena actual
            this.objects.forEach(o => this.scene.remove(o));
            this.objects = [];
            this.select(null);
            this.resizeHandles = [];
            
            // Restaurar c√°mara
            if(data.camera) {
                this.camera.position.set(data.camera.position.x, data.camera.position.y, data.camera.position.z);
                if(data.camera.target) {
                    this.controls.target.set(data.camera.target.x, data.camera.target.y, data.camera.target.z);
                }
            }
            
            // Recrear objetos
            data.objects.forEach(obj => {
                let newObj = null;
                
                switch(obj.type) {
                    case 'straight':
                        newObj = this.createStraight(obj.length);
                        if(obj.width) newObj.userData.width = obj.width;
                        break;
                    case 'curve':
                        newObj = this.createCurve(obj.radius, obj.angle);
                        if(obj.width) newObj.userData.width = obj.width;
                        break;
                    case 'roundabout':
                        newObj = this.createRoundaboutObj(obj.radius, obj.width);
                        break;
                    case 'parametricRoundabout':
                        newObj = this.createParametricRoundaboutObj(obj.diametro, obj.ancho);
                        break;
                    case 'octagon':
                        newObj = this.createOctagonObj(obj.area, obj.height);
                        break;
                    case 'pyramid':
                        newObj = this.createPyramidObj(obj.levels);
                        break;
                    case 'cybertruck':
                        newObj = this.createCybertruckObj();
                        break;
                }
                
                if(newObj) {
                    newObj.position.set(obj.position.x, obj.position.y, obj.position.z);
                    newObj.rotation.y = obj.rotation;
                    this.scene.add(newObj);
                    this.objects.push(newObj);
                    
                    // Para veh√≠culos, agregar a la lista de veh√≠culos
                    if(obj.type === 'cybertruck') {
                        this.vehicles.push(newObj);
                    }
                }
            });
            
            // Mostrar base
            this.showBaseArea();
        }

        // Agrega pir√°mides sin limpiar la escena existente
        addPyramidsToScene() {
            const V2V = this.OCT_RADIUS * 2;
            const cols = 2;
            const rows = 12;
            
            const spacingX = this.BASE_REAL_X / cols;
            const spacingZ = this.BASE_REAL_Z / rows;
            
            const startX = -this.BASE_REAL_X/2 + spacingX/2;
            const startZ = -this.BASE_REAL_Z/2 + spacingZ/2;
            
            // Zona de exclusi√≥n para la glorieta y carreteras centrales
            const exclusionRadius = 80; // No poner pir√°mides a menos de 80m del centro
            
            for(let row = 0; row < rows; row++) {
                for(let col = 0; col < cols; col++) {
                    const x = startX + col * spacingX;
                    const z = startZ + row * spacingZ;
                    
                    // Saltar si est√° muy cerca del centro (zona de carreteras)
                    if(Math.abs(z) < exclusionRadius) continue;
                    
                    const pyramid = this.createPyramidObj([6, 5, 4, 3, 2]);
                    pyramid.position.set(x, 0, z);
                    this.scene.add(pyramid);
                    this.objects.push(pyramid);
                }
            }
        }

        // --- TEXTURAS NUM√âRICAS PARA OCT√ÅGONO ---
        createNumberTextures() {
            return Array.from({length: 8}, (_, i) => {
                const canvas = document.createElement('canvas');
                canvas.width = 128; canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#111'; ctx.fillRect(0,0,128,128);
                ctx.fillStyle = '#ffcc00'; ctx.font = 'bold 90px Arial';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText((i + 1).toString(), 64, 64);
                return new THREE.CanvasTexture(canvas);
            });
        }

        // =====================================================
        // TESLA CYBERTRUCK - Modelo 3D a escala real
        // Dimensiones: 5.683m √ó 2.032m √ó 1.791m
        // =====================================================
        
        addCybertruck() {
            const truck = this.createCybertruckObj();
            truck.position.set(0, 0, 0);
            this.scene.add(truck);
            this.objects.push(truck);
            this.vehicles.push(truck);
            this.activeVehicle = truck;
            this.select(truck);
            return truck;
        }
        
        createCybertruckObj() {
            const g = new THREE.Group();
            const C = this.CYBER;
            
            g.userData = {
                type: 'cybertruck',
                // Dimensiones
                length: C.LENGTH,
                width: C.WIDTH,
                height: C.HEIGHT,
                wheelbase: C.WHEELBASE,
                // Estado de f√≠sica
                velocity: 0,           // Velocidad actual m/s
                angularVelocity: 0,    // Velocidad angular rad/s
                steering: 0,           // √Ångulo de direcci√≥n
                // Propiedades f√≠sicas
                maxSpeed: C.MAX_SPEED,
                acceleration: C.ACCELERATION,
                brakeForce: C.BRAKE_FORCE,
                turnRate: C.TURN_RATE,
                friction: C.FRICTION
            };
            
            this.buildCybertruck(g);
            return g;
        }
        
        buildCybertruck(g) {
            // Limpiar geometr√≠as anteriores
            g.children.forEach(c => { 
                if(c.geometry) c.geometry.dispose(); 
            });
            g.remove(...g.children);
            
            const C = this.CYBER;
            const L = C.LENGTH;      // 5.683m
            const W = C.WIDTH;       // 2.032m
            const H = C.HEIGHT;      // 1.791m
            const GC = C.GROUND_CLEARANCE; // 0.35m despeje
            
            // === CHASIS BASE (forma trapezoidal vista lateral) ===
            // La Cybertruck tiene forma angular caracter√≠stica
            
            // 1. CUERPO PRINCIPAL - Geometr√≠a angular
            const bodyShape = new THREE.Shape();
            // Vista lateral (perfil XY, luego extruido en Z)
            // Coordenadas relativas al centro del veh√≠culo
            const hL = L / 2;  // Media longitud
            const hH = H / 2;  // Media altura
            
            // Perfil lateral de la Cybertruck (forma triangular/angular)
            // Puntos del perfil (X = largo, Y = alto)
            bodyShape.moveTo(-hL, GC);                      // Frente inferior
            bodyShape.lineTo(-hL + 0.3, GC);                // Base frontal
            bodyShape.lineTo(-hL + 0.5, GC + 0.6);          // Subida frontal
            bodyShape.lineTo(-hL + 1.2, GC + 1.3);          // Parabrisas inicio
            bodyShape.lineTo(-hL + 2.2, H - 0.1);           // Techo frontal
            bodyShape.lineTo(hL - 2.0, H - 0.1);            // Techo trasero
            bodyShape.lineTo(hL - 0.8, GC + 0.8);           // Bajada trasera
            bodyShape.lineTo(hL, GC + 0.6);                 // Caja trasera
            bodyShape.lineTo(hL, GC);                       // Esquina trasera inferior
            bodyShape.lineTo(-hL, GC);                      // Cerrar forma
            
            const extrudeSettings = {
                depth: W,
                bevelEnabled: false
            };
            
            const bodyGeo = new THREE.ExtrudeGeometry(bodyShape, extrudeSettings);
            bodyGeo.translate(0, 0, -W/2); // Centrar en Z
            
            const body = new THREE.Mesh(bodyGeo, this.matCyberBody);
            body.castShadow = true;
            body.receiveShadow = true;
            body.name = 'body';
            g.add(body);
            
            // 2. BARRA DE LUZ FRONTAL (caracter√≠stica de la Cybertruck)
            const lightBarGeo = new THREE.BoxGeometry(0.05, 0.08, W - 0.2);
            const lightBar = new THREE.Mesh(lightBarGeo, this.matCyberLight);
            lightBar.position.set(-hL + 0.35, GC + 0.75, 0);
            lightBar.name = 'frontLightBar';
            g.add(lightBar);
            
            // 3. BARRA DE LUZ TRASERA
            const tailLightGeo = new THREE.BoxGeometry(0.05, 0.05, W - 0.3);
            const tailLight = new THREE.Mesh(tailLightGeo, this.matCyberTailLight);
            tailLight.position.set(hL - 0.05, GC + 0.9, 0);
            tailLight.name = 'tailLightBar';
            g.add(tailLight);
            
            // 4. VENTANAS (cristal oscuro)
            // Parabrisas frontal
            const windshieldGeo = new THREE.PlaneGeometry(1.2, W - 0.4);
            const windshield = new THREE.Mesh(windshieldGeo, this.matCyberWindow);
            windshield.position.set(-hL + 1.7, GC + 1.15, 0);
            windshield.rotation.z = -Math.PI / 4; // Inclinado
            windshield.rotation.y = Math.PI / 2;
            windshield.name = 'windshield';
            g.add(windshield);
            
            // 5. RUEDAS (4 ruedas con detalles)
            const wheelRadius = 0.45;
            const wheelWidth = 0.35;
            const wheelPositions = [
                { x: -C.WHEELBASE/2 + 0.3, z: W/2 - wheelWidth/2 - 0.1 },  // Frontal izq
                { x: -C.WHEELBASE/2 + 0.3, z: -W/2 + wheelWidth/2 + 0.1 }, // Frontal der
                { x: C.WHEELBASE/2 - 0.3, z: W/2 - wheelWidth/2 - 0.1 },   // Trasera izq
                { x: C.WHEELBASE/2 - 0.3, z: -W/2 + wheelWidth/2 + 0.1 }   // Trasera der
            ];
            
            wheelPositions.forEach((pos, i) => {
                const wheelGroup = new THREE.Group();
                
                // Neum√°tico
                const tireGeo = new THREE.CylinderGeometry(wheelRadius, wheelRadius, wheelWidth, 24);
                const tire = new THREE.Mesh(tireGeo, this.matCyberWheel);
                tire.rotation.x = Math.PI / 2;
                wheelGroup.add(tire);
                
                // Rin (llanta)
                const rimGeo = new THREE.CylinderGeometry(wheelRadius * 0.65, wheelRadius * 0.65, wheelWidth + 0.02, 6);
                const rimMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8, roughness: 0.3 });
                const rim = new THREE.Mesh(rimGeo, rimMat);
                rim.rotation.x = Math.PI / 2;
                wheelGroup.add(rim);
                
                wheelGroup.position.set(pos.x, wheelRadius, pos.z);
                wheelGroup.name = `wheel_${i}`;
                wheelGroup.userData.isFront = i < 2; // Ruedas frontales giran
                g.add(wheelGroup);
            });
            
            // 6. CAJA DE CARGA (Vault)
            const vaultGeo = new THREE.BoxGeometry(1.85, 0.4, 1.3);
            const vault = new THREE.Mesh(vaultGeo, this.matCyberBody);
            vault.position.set(hL - 1.0, GC + 0.6, 0);
            vault.name = 'vault';
            g.add(vault);
            
            // 7. ETIQUETA INFORMATIVA
            this.addCybertruckLabel(g);
            
            // 8. HIGHLIGHT para selecci√≥n
            const highlightGeo = new THREE.BoxGeometry(L + 0.2, H + 0.2, W + 0.2);
            const highlight = new THREE.Mesh(highlightGeo, new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            }));
            highlight.position.y = H / 2 + GC;
            highlight.visible = false;
            highlight.name = 'highlight';
            g.add(highlight);
        }
        
        addCybertruckLabel(g) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, 512, 128);
            
            ctx.fillStyle = '#10b981';
            ctx.font = 'bold 26px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Tesla Cybertruck', 256, 35);
            
            ctx.fillStyle = '#60a5fa';
            ctx.font = '20px Arial';
            ctx.fillText(`${this.CYBER.LENGTH}m √ó ${this.CYBER.WIDTH}m √ó ${this.CYBER.HEIGHT}m`, 256, 70);
            
            ctx.fillStyle = '#888';
            ctx.font = '16px Arial';
            ctx.fillText('WASD: Mover | Q/E: Girar | Shift: Turbo', 256, 105);
            
            const tex = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: tex });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.position.set(0, this.CYBER.HEIGHT + 1.5, 0);
            sprite.scale.set(8, 2, 1);
            sprite.name = 'label';
            g.add(sprite);
        }
        
        // === F√çSICA Y MOVIMIENTO DE VEH√çCULOS ===
        updateVehicles(deltaTime) {
            this.vehicles.forEach(vehicle => {
                if(vehicle.userData.type !== 'cybertruck') return;
                
                const data = vehicle.userData;
                let acceleration = 0;
                
                // Solo mover si este veh√≠culo est√° activo/seleccionado
                if(this.activeVehicle === vehicle || this.selected === vehicle) {
                    const turboMultiplier = this.vehicleKeys.turbo ? 1.8 : 1.0;
                    
                    // Acelerar/Frenar
                    if(this.vehicleKeys.forward) {
                        acceleration = data.acceleration * turboMultiplier;
                    } else if(this.vehicleKeys.backward) {
                        if(data.velocity > 0.5) {
                            // Frenando
                            acceleration = -data.brakeForce;
                        } else {
                            // Reversa
                            acceleration = -data.acceleration * 0.5;
                        }
                    }
                    
                    // Girar (solo si hay velocidad)
                    if(Math.abs(data.velocity) > 0.1) {
                        const turnFactor = Math.min(1, Math.abs(data.velocity) / 10) * Math.sign(data.velocity);
                        if(this.vehicleKeys.left) {
                            vehicle.rotation.y += data.turnRate * deltaTime * turnFactor;
                        }
                        if(this.vehicleKeys.right) {
                            vehicle.rotation.y -= data.turnRate * deltaTime * turnFactor;
                        }
                    }
                }
                
                // Aplicar f√≠sica
                data.velocity += acceleration * deltaTime;
                data.velocity *= data.friction; // Fricci√≥n
                
                // Limitar velocidad
                const maxSpd = this.vehicleKeys.turbo ? data.maxSpeed * 1.5 : data.maxSpeed;
                data.velocity = Math.max(-maxSpd * 0.3, Math.min(maxSpd, data.velocity));
                
                // Detener si velocidad muy baja
                if(Math.abs(data.velocity) < 0.05 && acceleration === 0) {
                    data.velocity = 0;
                }
                
                // Mover veh√≠culo (el frente est√° en -X local, as√≠ que usamos cos/sin invertidos)
                if(data.velocity !== 0) {
                    // Direcci√≥n: el frente de la Cybertruck apunta hacia -X local
                    // Con rotation.y = 0, el frente mira hacia -X global
                    // Entonces movemos en la direcci√≥n del frente (eje -X rotado)
                    const moveX = -Math.cos(vehicle.rotation.y) * data.velocity * deltaTime;
                    const moveZ = Math.sin(vehicle.rotation.y) * data.velocity * deltaTime;
                    vehicle.position.x += moveX;
                    vehicle.position.z += moveZ;
                    
                    // Animar ruedas
                    this.animateWheels(vehicle, data.velocity * deltaTime);
                    
                    // Verificar snap con carreteras
                    this.checkVehicleRoadSnap(vehicle);
                }
            });
        }
        
        animateWheels(vehicle, distance) {
            const wheelRadius = 0.45;
            const rotationAngle = distance / wheelRadius;
            
            vehicle.children.forEach(child => {
                if(child.name && child.name.startsWith('wheel_')) {
                    // Rotar la rueda sobre su eje
                    const tire = child.children[0];
                    if(tire) {
                        tire.rotation.y += rotationAngle;
                    }
                }
            });
        }
        
        // === SNAP DE VEH√çCULO CON CARRETERAS ===
        checkVehicleRoadSnap(vehicle) {
            const SNAP_DIST = 4; // Distancia de snap reducida (4 metros)
            const SNAP_ANGLE = 0.3; // Tolerancia angular en radianes (~17¬∞)
            const CENTER_THRESHOLD = 3.0; // Umbral para centrar en carril (muy relajado)
            const ANGLE_SMOOTH = 0.02; // Factor de suavizado angular (muy suave)
            const CENTER_SMOOTH = 0.004; // Factor de suavizado de centrado (muy suave)
            const vPos = vehicle.position;
            
            let bestSnap = null;
            let bestDist = Infinity;
            
            for(let obj of this.objects) {
                if(obj === vehicle) continue;
                
                // Para carreteras rectas
                if(obj.userData.type === 'straight') {
                    const roadPos = obj.position;
                    const roadRot = obj.rotation.y;
                    const roadLen = obj.userData.length / 2;
                    const roadWidth = obj.userData.width / 2;
                    
                    // Direcci√≥n de la carretera (a lo largo de Z local de la carretera)
                    // rotation.y = 0 significa que la carretera va de -Z a +Z
                    const roadDirX = Math.sin(roadRot);
                    const roadDirZ = Math.cos(roadRot);
                    
                    // Vector del veh√≠culo a la carretera
                    const dx = vPos.x - roadPos.x;
                    const dz = vPos.z - roadPos.z;
                    
                    // Proyecci√≥n sobre la direcci√≥n de la carretera
                    const alongRoad = dx * roadDirX + dz * roadDirZ;
                    // Proyecci√≥n perpendicular (distancia al centro)
                    const perpRoad = dx * roadDirZ - dz * roadDirX;
                    
                    // Verificar si est√° sobre la carretera
                    if(Math.abs(alongRoad) < roadLen + 2 && Math.abs(perpRoad) < roadWidth + 2) {
                        const dist = Math.abs(perpRoad);
                        if(dist < bestDist) {
                            bestDist = dist;
                            bestSnap = {
                                type: 'straight',
                                roadRot: roadRot,
                                perpRoad: perpRoad,
                                perpDirX: roadDirZ,  // Direcci√≥n perpendicular
                                perpDirZ: -roadDirX
                            };
                        }
                    }
                }
                
                // Para glorietas/rotondas
                if(obj.userData.type === 'roundabout' || obj.userData.type === 'parametricRoundabout') {
                    const center = obj.position;
                    const radius = obj.userData.radius || obj.userData.diametro / 2;
                    const width = obj.userData.width || obj.userData.ancho || 10;
                    
                    // Distancia al centro de la glorieta
                    const dx = vPos.x - center.x;
                    const dz = vPos.z - center.z;
                    const distToCenter = Math.sqrt(dx * dx + dz * dz);
                    
                    // Radio del carril (centro de la carretera de la glorieta)
                    const laneRadius = radius;
                    const innerRadius = radius - width/2;
                    const outerRadius = radius + width/2;
                    
                    // Verificar si est√° en el anillo de la glorieta
                    if(distToCenter > innerRadius - 2 && distToCenter < outerRadius + 2) {
                        const distFromLane = Math.abs(distToCenter - laneRadius);
                        if(distFromLane < bestDist) {
                            // √Ångulo tangencial (direcci√≥n de circulaci√≥n)
                            const angleToCenter = Math.atan2(dx, dz);
                            bestDist = distFromLane;
                            bestSnap = {
                                type: 'roundabout',
                                // Tangente a la circunferencia (sentido antihorario)
                                tangentAngle: angleToCenter + Math.PI / 2,
                                distFromLane: distToCenter - laneRadius,
                                center: center,
                                laneRadius: laneRadius
                            };
                        }
                    }
                }
            }
            
            // Aplicar snap si encontramos una carretera cercana
            if(bestSnap) {
                const vehicleAngle = vehicle.rotation.y;
                
                if(bestSnap.type === 'straight') {
                    // Para rectas: alinear con la direcci√≥n de la carretera
                    // El frente del veh√≠culo est√° en -X local, as√≠ que a√±adimos PI/2
                    const roadAngle1 = bestSnap.roadRot + Math.PI / 2;
                    const roadAngle2 = bestSnap.roadRot - Math.PI / 2;
                    
                    // Elegir el √°ngulo m√°s cercano a la direcci√≥n actual
                    const diff1 = this.normalizeAngle(roadAngle1 - vehicleAngle);
                    const diff2 = this.normalizeAngle(roadAngle2 - vehicleAngle);
                    
                    const targetAngle = Math.abs(diff1) < Math.abs(diff2) ? roadAngle1 : roadAngle2;
                    const angleDiff = this.normalizeAngle(targetAngle - vehicleAngle);
                    
                    if(Math.abs(angleDiff) < SNAP_ANGLE) {
                        // Snap de √°ngulo suave
                        vehicle.rotation.y += angleDiff * ANGLE_SMOOTH;
                        
                        // Centrar en el carril (solo si est√° lejos del centro)
                        if(Math.abs(bestSnap.perpRoad) > CENTER_THRESHOLD) {
                            const centerForce = -bestSnap.perpRoad * CENTER_SMOOTH;
                            vehicle.position.x += centerForce * bestSnap.perpDirX;
                            vehicle.position.z += centerForce * bestSnap.perpDirZ;
                        }
                    }
                } else if(bestSnap.type === 'roundabout') {
                    // Para glorietas: alinear con la tangente
                    const tangent1 = bestSnap.tangentAngle;
                    const tangent2 = bestSnap.tangentAngle + Math.PI;
                    
                    const diff1 = this.normalizeAngle(tangent1 - vehicleAngle);
                    const diff2 = this.normalizeAngle(tangent2 - vehicleAngle);
                    
                    const targetAngle = Math.abs(diff1) < Math.abs(diff2) ? tangent1 : tangent2;
                    const angleDiff = this.normalizeAngle(targetAngle - vehicleAngle);
                    
                    if(Math.abs(angleDiff) < SNAP_ANGLE * 1.5) {
                        // Snap angular m√°s suave en glorietas
                        vehicle.rotation.y += angleDiff * (ANGLE_SMOOTH * 0.8);
                        
                        // Mantener en el radio correcto (solo si est√° lejos)
                        if(Math.abs(bestSnap.distFromLane) > CENTER_THRESHOLD) {
                            const dx = vPos.x - bestSnap.center.x;
                            const dz = vPos.z - bestSnap.center.z;
                            const currentDist = Math.sqrt(dx * dx + dz * dz);
                            const correction = (bestSnap.laneRadius - currentDist) * CENTER_SMOOTH;
                            vehicle.position.x += (dx / currentDist) * correction;
                            vehicle.position.z += (dz / currentDist) * correction;
                        }
                    }
                }
            }
        }
        
        normalizeAngle(angle) {
            while(angle > Math.PI) angle -= 2 * Math.PI;
            while(angle < -Math.PI) angle += 2 * Math.PI;
            return angle;
        }

        // --- M√ìDULO OCTAGONAL 50m¬≤ ---
        addOctagon() {
            const oct = this.createOctagonObj(this.OCT_AREA, this.OCT_HEIGHT); // 50m¬≤, 3m altura
            oct.position.set(Math.random()*20 - 10, this.OCT_HEIGHT/2, Math.random()*20 - 10);
            this.scene.add(oct); this.objects.push(oct); this.select(oct);
        }

        // === MOSTRAR BASE 140√ó100m ===
        showBaseArea() {
            // Eliminar base anterior si existe
            const oldBase = this.scene.getObjectByName('baseArea');
            if(oldBase) this.scene.remove(oldBase);

            const baseGeo = new THREE.PlaneGeometry(this.BASE_REAL_X, this.BASE_REAL_Z);
            const baseMat = new THREE.MeshBasicMaterial({ 
                color: 0x0066ff, 
                transparent: true, 
                opacity: 0.15,
                side: THREE.DoubleSide 
            });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.rotation.x = -Math.PI / 2;
            base.position.y = 0.01;
            base.name = 'baseArea';
            this.scene.add(base);

            // Borde de la base
            const borderGeo = new THREE.EdgesGeometry(baseGeo);
            const borderMat = new THREE.LineBasicMaterial({ color: 0x0088ff, linewidth: 2 });
            const border = new THREE.LineSegments(borderGeo, borderMat);
            border.rotation.x = -Math.PI / 2;
            border.position.y = 0.02;
            base.add(border);

            // Etiquetas de dimensi√≥n (escala 1:300)
            this.addDimensionLabel(0, 0.5, -this.BASE_REAL_Z/2 - 3, '210m (70cm)');
            this.addDimensionLabel(-this.BASE_REAL_X/2 - 5, 0.5, 0, '150m (50cm)');
        }

        addDimensionLabel(x, y, z, text) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#0088ff'; ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, 128, 32);
            const tex = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: tex });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.position.set(x, y, z);
            sprite.scale.set(20, 5, 1);
            sprite.name = 'baseArea';
            this.scene.add(sprite);
        }

        // === PIR√ÅMIDE DE OCT√ÅGONOS (6‚Üí2) ===
        addPyramid() {
            const pyramid = this.createPyramidObj([6, 5, 4, 3, 2]); // Niveles de oct√°gonos
            pyramid.position.set(0, 0, 0);
            this.scene.add(pyramid); this.objects.push(pyramid); this.select(pyramid);
        }

        createPyramidObj(levels) {
            const g = new THREE.Group();
            g.userData = { type: 'pyramid', levels: levels };
            
            const V2V = this.OCT_RADIUS * 2; // V√©rtice a v√©rtice
            const C2C = this.OCT_FACE_DIST;   // Cara a cara (profundidad)
            const h = this.OCT_HEIGHT;
            
            let yPos = h / 2;
            levels.forEach((count, levelIdx) => {
                const levelWidth = count * V2V;
                const startX = -levelWidth / 2 + V2V / 2;
                
                for(let i = 0; i < count; i++) {
                    const oct = this.createOctagonObj(this.OCT_AREA, h);
                    oct.position.set(startX + i * V2V, yPos, 0);
                    g.add(oct);
                    // Remover de objects ya que es parte del grupo
                    const idx = this.objects.indexOf(oct);
                    if(idx > -1) this.objects.splice(idx, 1);
                }
                yPos += h; // Siguiente nivel
            });
            
            return g;
        }

        // === GENERAR GRID 2√ó12 PIR√ÅMIDES ===
        generatePyramidGrid() {
            // Limpiar escena
            this.objects.forEach(o => this.scene.remove(o));
            this.objects = []; this.select(null);
            
            // Mostrar base
            this.showBaseArea();
            
            // Dimensiones pir√°mide (en metros reales)
            const V2V = this.OCT_RADIUS * 2; // ~8.408m
            const pyramidWidth = 6 * V2V;     // ~50.45m frente
            const pyramidDepth = this.OCT_FACE_DIST; // ~7.77m profundidad
            
            const cols = 2;  // 2 pir√°mides a lo ancho (140m)
            const rows = 12; // 12 filas en profundidad (100m)
            
            const spacingX = this.BASE_REAL_X / cols; // ~70m entre centros
            const spacingZ = this.BASE_REAL_Z / rows; // ~8.33m entre centros
            
            const startX = -this.BASE_REAL_X/2 + spacingX/2;
            const startZ = -this.BASE_REAL_Z/2 + spacingZ/2;
            
            for(let row = 0; row < rows; row++) {
                for(let col = 0; col < cols; col++) {
                    const pyramid = this.createPyramidObj([6, 5, 4, 3, 2]);
                    pyramid.position.set(
                        startX + col * spacingX,
                        0,
                        startZ + row * spacingZ
                    );
                    this.scene.add(pyramid);
                    this.objects.push(pyramid);
                }
            }
            
            // Ajustar c√°mara para ver todo  
            this.camera.position.set(0, 120, 150);
            this.camera.lookAt(0, 0, 0);
        }

        // === GENERAR CARRETERA PERIMETRAL ===
        generatePerimeterRoad() {
            // Dimensiones base: 140m x 100m
            const W = this.BASE_REAL_X; // 140m (ancho)
            const D = this.BASE_REAL_Z; // 100m (profundidad)
            const roadWidth = 10; // ancho de carretera
            const curveRadius = 25; // radio de las curvas (codos)
            
            // Longitudes de las rectas (descontando el espacio de las curvas)
            const straightLengthX = W - 2 * curveRadius; // ~90m en X
            const straightLengthZ = D - 2 * curveRadius; // ~50m en Z
            
            // Offset para que la carretera quede fuera del √°rea base
            const offset = roadWidth / 2 + 2; // Margen de 2m
            const halfW = W / 2 + offset;
            const halfD = D / 2 + offset;
            
            // === GLORIETA CENTRAL ===
            const glorieta = this.createRoundaboutObj(30, roadWidth);
            glorieta.position.set(0, 0, 0);
            this.scene.add(glorieta); this.objects.push(glorieta);
            
            // === 4 RECTAS PERIMETRALES ===
            // Recta Superior (Norte)
            const roadN = this.createStraight(straightLengthX);
            roadN.position.set(0, 0, -halfD + curveRadius);
            roadN.rotation.y = Math.PI / 2; // Horizontal
            this.scene.add(roadN); this.objects.push(roadN);
            
            // Recta Inferior (Sur)
            const roadS = this.createStraight(straightLengthX);
            roadS.position.set(0, 0, halfD - curveRadius);
            roadS.rotation.y = Math.PI / 2; // Horizontal
            this.scene.add(roadS); this.objects.push(roadS);
            
            // Recta Izquierda (Oeste)
            const roadW = this.createStraight(straightLengthZ);
            roadW.position.set(-halfW + curveRadius, 0, 0);
            roadW.rotation.y = 0; // Vertical
            this.scene.add(roadW); this.objects.push(roadW);
            
            // Recta Derecha (Este)
            const roadE = this.createStraight(straightLengthZ);
            roadE.position.set(halfW - curveRadius, 0, 0);
            roadE.rotation.y = 0; // Vertical
            this.scene.add(roadE); this.objects.push(roadE);
            
            // === 4 RECTAS CONECTANDO GLORIETA CON PER√çMETRO ===
            const glorietaRadius = 30;
            // Norte (conecta glorieta con recta Norte)
            const connectN = this.createStraight(halfD - curveRadius - glorietaRadius);
            connectN.position.set(0, 0, -(halfD - curveRadius + glorietaRadius) / 2);
            connectN.rotation.y = 0;
            this.scene.add(connectN); this.objects.push(connectN);
            
            // Sur (conecta glorieta con recta Sur)
            const connectS = this.createStraight(halfD - curveRadius - glorietaRadius);
            connectS.position.set(0, 0, (halfD - curveRadius + glorietaRadius) / 2);
            connectS.rotation.y = 0;
            this.scene.add(connectS); this.objects.push(connectS);
            
            // Oeste (conecta glorieta con recta Oeste)
            const connectW = this.createStraight(halfW - curveRadius - glorietaRadius);
            connectW.position.set(-(halfW - curveRadius + glorietaRadius) / 2, 0, 0);
            connectW.rotation.y = Math.PI / 2;
            this.scene.add(connectW); this.objects.push(connectW);
            
            // Este (conecta glorieta con recta Este)
            const connectE = this.createStraight(halfW - curveRadius - glorietaRadius);
            connectE.position.set((halfW - curveRadius + glorietaRadius) / 2, 0, 0);
            connectE.rotation.y = Math.PI / 2;
            this.scene.add(connectE); this.objects.push(connectE);
            
            // === 4 CODOS (esquinas) ===
            // Esquina Noreste
            const curveNE = this.createCurve(curveRadius, 90);
            curveNE.position.set(halfW - curveRadius, 0, -halfD + curveRadius);
            curveNE.rotation.y = 0;
            this.scene.add(curveNE); this.objects.push(curveNE);
            
            // Esquina Noroeste
            const curveNW = this.createCurve(curveRadius, 90);
            curveNW.position.set(-halfW + curveRadius, 0, -halfD + curveRadius);
            curveNW.rotation.y = Math.PI / 2;
            this.scene.add(curveNW); this.objects.push(curveNW);
            
            // Esquina Suroeste
            const curveSW = this.createCurve(curveRadius, 90);
            curveSW.position.set(-halfW + curveRadius, 0, halfD - curveRadius);
            curveSW.rotation.y = Math.PI;
            this.scene.add(curveSW); this.objects.push(curveSW);
            
            // Esquina Sureste
            const curveSE = this.createCurve(curveRadius, 90);
            curveSE.position.set(halfW - curveRadius, 0, halfD - curveRadius);
            curveSE.rotation.y = -Math.PI / 2;
            this.scene.add(curveSE); this.objects.push(curveSE);
            
            // Mostrar base si no est√° visible
            if(!this.scene.getObjectByName('baseArea')) {
                this.showBaseArea();
            }
            
            // === APLICAR SNAP AUTOM√ÅTICO ===
            const roadPieces = [roadN, roadS, roadW, roadE, curveNE, curveNW, curveSW, curveSE, connectN, connectS, connectW, connectE];
            this.autoSnapRoadPieces(roadPieces);
        }
        
        autoSnapRoadPieces(pieces) {
            // Aplicar snap a cada pieza contra el resto
            const SNAP_DIST = 8; // Distancia de snap reducida
            for(let i = 0; i < pieces.length; i++) {
                for(let j = i + 1; j < pieces.length; j++) {
                    const p1 = pieces[i];
                    const p2 = pieces[j];
                    const cons1 = this.getConnectors(p1);
                    const cons2 = this.getConnectors(p2);
                    
                    for(let c1 of cons1) {
                        for(let c2 of cons2) {
                            if(c1.pos.distanceTo(c2.pos) < SNAP_DIST) {
                                // Conectar p1 a p2
                                const offset = new THREE.Vector3().subVectors(c1.pos, p1.position);
                                p1.position.subVectors(c2.pos, offset);
                                
                                // Alinear rotaci√≥n
                                const targetAngle = Math.atan2(c2.dir.x, c2.dir.z) + Math.PI;
                                const currentAngle = Math.atan2(c1.dir.x, c1.dir.z);
                                let delta = targetAngle - currentAngle;
                                p1.rotation.y += delta;
                            }
                        }
                    }
                }
            }
        }

        createOctagonObj(area, height) {
            const g = new THREE.Group();
            // Radio desde √°rea: Area = 2 * sqrt(2) * R¬≤
            const radius = Math.sqrt(area / (2 * Math.sqrt(2)));
            g.userData = { type: 'octagon', area: area, radius: radius, height: height };
            this.buildOctagon(g);
            return g;
        }

        buildOctagon(g) {
            g.children.forEach(c => { if(c.geometry) c.geometry.dispose(); });
            g.remove(...g.children);
            const { radius, height } = g.userData;
            const SEGMENTS = 8;

            // 1. Paredes (cilindro octagonal)
            const wallGeo = new THREE.CylinderGeometry(radius, radius, height, SEGMENTS);
            const mat = this.selected === g ? this.matSel : this.matOctWall;
            const walls = new THREE.Mesh(wallGeo, mat);
            walls.castShadow = true; walls.receiveShadow = true;
            g.add(walls);

            // 2. V√©rtices (esferas amarillas)
            const vertexGeo = new THREE.SphereGeometry(0.25, 8, 8);
            for (let j = 0; j < 2; j++) {
                const yPos = j === 0 ? -height/2 : height/2;
                for (let i = 0; i < SEGMENTS; i++) {
                    const angle = i * (Math.PI * 2 / SEGMENTS);
                    const v = new THREE.Mesh(vertexGeo, this.matOctVertex);
                    v.position.set(Math.cos(angle) * radius, yPos, Math.sin(angle) * radius);
                    g.add(v);
                }
            }

            // 3. Etiquetas num√©ricas en caras
            const labelGeo = new THREE.PlaneGeometry(1.2, 1.2);
            for (let i = 0; i < SEGMENTS; i++) {
                const angle = (i + 0.5) * (Math.PI * 2 / SEGMENTS);
                const lx = Math.cos(angle) * (radius + 0.05);
                const lz = Math.sin(angle) * (radius + 0.05);
                const label = new THREE.Mesh(labelGeo, new THREE.MeshBasicMaterial({ map: this.octTextures[i], transparent: true }));
                label.position.set(lx, 0, lz);
                label.lookAt(lx * 2, 0, lz * 2);
                g.add(label);
            }

            // 4. Tapas (base y techo)
            const capGeo = new THREE.CylinderGeometry(radius, radius, 0.1, SEGMENTS);
            const topCap = new THREE.Mesh(capGeo, this.matOctCap); topCap.position.y = height/2; g.add(topCap);
            const btmCap = new THREE.Mesh(capGeo, this.matOctCap); btmCap.position.y = -height/2; g.add(btmCap);

            // 5. Highlight para selecci√≥n
            const highlight = new THREE.Mesh(
                new THREE.CylinderGeometry(radius * 1.05, radius * 1.05, height, SEGMENTS),
                this.matOctHighlight
            );
            highlight.visible = false;
            highlight.name = 'highlight';
            g.add(highlight);
        }

        // --- OPCI√ìN 2: DISTRIBUIDOR RADIAL ---
        // Crea una glorieta central con 8 carreteras radiales conectadas
        // Basado en el dise√±o de simuladorPlantilla2.html
        addRadialHub() {
            // Par√°metros del distribuidor (estilo plantilla 2)
            const hubRadius = 50;      // Radio del eje de la glorieta (50m)
            const roadWidth = 10;      // Ancho de carretera (10m)
            const armLength = 100;     // Longitud de cada brazo (100m)
            const numArms = 8;         // 8 brazos radiales
            
            // Crear Glorieta Central usando createRoundaboutObj (con isla verde)
            const hub = this.createRoundaboutObj(hubRadius, roadWidth);
            hub.position.set(0, 0, 0);
            this.scene.add(hub); 
            this.objects.push(hub);

            // Crear 8 rectas conectadas radialmente
            for(let i = 0; i < numArms; i++) {
                const road = this.createStraight(armLength);
                
                // √Ångulo del brazo (cada 45¬∞)
                const angle = (i * 45) * (Math.PI / 180);
                
                // La recta en Three.js va de -Z a +Z cuando rotation.y = 0
                // Rotamos para que apunte radialmente hacia afuera
                road.rotation.y = angle;
                
                // Posici√≥n: el centro de la recta est√° a distancia = radio + longitud/2
                // Para que el extremo interior toque el borde exterior de la glorieta
                const outerRadius = hubRadius + roadWidth / 2;
                const dist = outerRadius + armLength / 2;
                
                road.position.set(
                    Math.cos(angle) * dist,
                    0,
                    Math.sin(angle) * dist
                );

                this.scene.add(road);
                this.objects.push(road);
            }
            
            // Ajustar c√°mara para ver todo el distribuidor
            this.camera.position.set(0, 250, 300);
            this.camera.lookAt(0, 0, 0);
            
            this.select(hub);
        }

        // --- FUNCIONES CORE ---

        addRoundabout() {
            const g = this.createRoundaboutObj(155, 10);
            g.position.set(0, 0, 0);
            this.scene.add(g); this.objects.push(g); this.select(g);
        }

        // =====================================================
        // GLORIETA PARAM√âTRICA
        // =====================================================
        // Descripci√≥n: Glorieta con di√°metro ajustable (10-100m)
        // Ancho fijo de carretera: 10 metros
        // 
        // Para inicializar: editor.addParametricRoundabout()
        // Para modificar di√°metro: seleccionar y usar slider
        // O program√°ticamente: editor.setDiameter(nuevoDiametro)
        // =====================================================
        
        /**
         * A√±ade una glorieta param√©trica a la escena
         * @param {number} diametro - Di√°metro inicial (10-100m), default 50m
         */
        addParametricRoundabout(diametro = 50) {
            // Constantes de la glorieta param√©trica
            const ANCHO_GLORIETA = 10; // Ancho fijo de 10 metros
            const DIAMETRO_MIN = 10;
            const DIAMETRO_MAX = 200; // Permite hasta ~31,416 m¬≤
            
            // Validar di√°metro dentro del rango
            diametro = Math.max(DIAMETRO_MIN, Math.min(DIAMETRO_MAX, diametro));
            
            const g = this.createParametricRoundaboutObj(diametro, ANCHO_GLORIETA);
            g.position.set(0, 0, 0);
            this.scene.add(g);
            this.objects.push(g);
            this.select(g);
            return g;
        }

        /**
         * Crea el objeto de glorieta param√©trica
         * @param {number} diametro - Di√°metro de la glorieta en metros
         * @param {number} ancho - Ancho de la carretera (fijo: 10m)
         */
        createParametricRoundaboutObj(diametro, ancho) {
            const g = new THREE.Group();
            // Almacenar par√°metros en userData para edici√≥n posterior
            g.userData = { 
                type: 'parametricRoundabout', 
                diametro: diametro,      // Di√°metro total
                ancho: ancho,            // Ancho de carretera (fijo: 10m)
                diametroMin: 10,
                diametroMax: 200         // Permite hasta ~31,416 m¬≤
            };
            this.buildParametricRoundabout(g);
            return g;
        }

        /**
         * Construye/reconstruye la geometr√≠a de la glorieta
         * @param {THREE.Group} g - Grupo de la glorieta
         */
        buildParametricRoundabout(g) {
            // Limpiar geometr√≠as anteriores
            g.children.forEach(c => { if(c.geometry) c.geometry.dispose(); });
            g.remove(...g.children);
            
            const { diametro, ancho } = g.userData;
            
            // Calcular radios
            // Radio exterior = di√°metro / 2
            // Radio interior = radio exterior - ancho
            const radioExterior = diametro / 2;
            const radioInterior = Math.max(0, radioExterior - ancho);
            const radioEje = (radioExterior + radioInterior) / 2; // Radio del eje central
            
            // 1. Isla central (√°rea verde)
            if(radioInterior > 0) {
                const islaGeo = new THREE.CircleGeometry(radioInterior, 64);
                const isla = new THREE.Mesh(islaGeo, this.matGrass);
                isla.rotation.x = -Math.PI / 2;
                isla.position.y = 0.02;
                isla.name = 'isla';
                g.add(isla);
            }
            
            // 2. Carretera (anillo)
            const carGeo = new THREE.RingGeometry(radioInterior, radioExterior, 64);
            const mat = this.selected === g ? this.matSel : this.matRoad;
            const carretera = new THREE.Mesh(carGeo, mat);
            carretera.rotation.x = -Math.PI / 2;
            carretera.receiveShadow = true;
            carretera.name = 'carretera';
            g.add(carretera);
            
            // 3. L√≠nea central (eje)
            const lineaGeo = new THREE.RingGeometry(radioEje - 0.2, radioEje + 0.2, 64);
            const linea = new THREE.Mesh(lineaGeo, this.matLines);
            linea.rotation.x = -Math.PI / 2;
            linea.position.y = 0.05;
            linea.name = 'lineaCentral';
            g.add(linea);
            
            // 4. L√≠neas de borde (interior y exterior)
            if(radioInterior > 0.5) {
                const bordeIntGeo = new THREE.RingGeometry(radioInterior - 0.15, radioInterior + 0.15, 64);
                const bordeInt = new THREE.Mesh(bordeIntGeo, this.matLines);
                bordeInt.rotation.x = -Math.PI / 2;
                bordeInt.position.y = 0.04;
                bordeInt.name = 'bordeInterior';
                g.add(bordeInt);
            }
            
            const bordeExtGeo = new THREE.RingGeometry(radioExterior - 0.15, radioExterior + 0.15, 64);
            const bordeExt = new THREE.Mesh(bordeExtGeo, this.matLines);
            bordeExt.rotation.x = -Math.PI / 2;
            bordeExt.position.y = 0.04;
            bordeExt.name = 'bordeExterior';
            g.add(bordeExt);
            
            // 5. Etiqueta informativa (sprite)
            this.addRoundaboutLabel(g, diametro, ancho);
        }
        
        /**
         * A√±ade etiqueta informativa a la glorieta
         * Muestra: di√°metro, √°rea total y dimensiones en maqueta 1:300
         */
        addRoundaboutLabel(g, diametro, ancho) {
            const radioExterior = diametro / 2;
            const areaTotal = Math.PI * radioExterior * radioExterior; // A = œÄr¬≤
            const diametroMaqueta = (diametro / 3).toFixed(1); // Escala 1:300
            
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Fondo semitransparente
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0, 0, 512, 128);
            
            // L√≠nea 1: Di√°metro y √°rea
            ctx.fillStyle = '#22c55e';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`‚åÄ${diametro}m | √Årea: ${areaTotal.toFixed(0)} m¬≤`, 256, 40);
            
            // L√≠nea 2: Maqueta
            ctx.fillStyle = '#60a5fa';
            ctx.font = '22px Arial';
            ctx.fillText(`Maqueta 1:300: ‚åÄ${diametroMaqueta}cm`, 256, 85);
            
            const tex = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: tex });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.position.set(0, 8, 0);
            sprite.scale.set(25, 6, 1);
            sprite.name = 'etiqueta';
            g.add(sprite);
        }
        
        /**
         * Actualiza el di√°metro de la glorieta seleccionada
         * @param {number} nuevoDiametro - Nuevo di√°metro (10-200m)
         */
        setDiameter(nuevoDiametro) {
            if(!this.selected || this.selected.userData.type !== 'parametricRoundabout') return;
            
            const { diametroMin, diametroMax } = this.selected.userData;
            nuevoDiametro = Math.max(diametroMin, Math.min(diametroMax, parseFloat(nuevoDiametro)));
            
            this.selected.userData.diametro = nuevoDiametro;
            
            // Calcular √°rea: A = œÄ * r¬≤
            const radio = nuevoDiametro / 2;
            const area = Math.PI * radio * radio;
            const diametroMaqueta = (nuevoDiametro / 3).toFixed(1); // Escala 1:300
            
            document.getElementById('lblDiam').innerText = nuevoDiametro + 'm';
            document.getElementById('lblArea').innerHTML = `√Årea: <strong>${area.toFixed(0)} m¬≤</strong> | Maqueta: ‚åÄ${diametroMaqueta}cm`;
            
            this.buildParametricRoundabout(this.selected);
        }

        createRoundaboutObj(radius, width) {
            const g = new THREE.Group();
            g.userData = { type: 'roundabout', radius: radius, width: width }; 
            this.buildRoundabout(g);
            return g;
        }

        buildRoundabout(g) {
            g.children.forEach(c => { if(c.geometry) c.geometry.dispose(); });
            g.remove(...g.children);
            const { radius, width } = g.userData; 
            const islandRadius = radius - (width/2);
            const outerRadius = radius + (width/2);

            // Isla central verde
            const grassGeo = new THREE.CircleGeometry(islandRadius, 64);
            const grass = new THREE.Mesh(grassGeo, this.matGrass);
            grass.rotation.x = -Math.PI/2; grass.position.y = 0.02;
            grass.name = 'isla';
            g.add(grass);

            // V√≠a (anillo de carretera)
            const roadGeo = new THREE.RingGeometry(islandRadius, outerRadius, 64);
            const mat = this.selected === g ? this.matSel : this.matRoad;
            const road = new THREE.Mesh(roadGeo, mat);
            road.rotation.x = -Math.PI/2; road.receiveShadow = true;
            road.name = 'carretera';
            g.add(road);

            // L√≠nea central del eje
            const lGeo = new THREE.RingGeometry(radius - 0.2, radius + 0.2, 64);
            const line = new THREE.Mesh(lGeo, this.matLines);
            line.rotation.x = -Math.PI/2; line.position.y = 0.05;
            g.add(line);
            
            // Etiqueta con dimensiones y √°rea
            this.addRoundaboutInfoLabel(g, radius, width);
        }
        
        // Etiqueta informativa para roundabout cl√°sico
        addRoundaboutInfoLabel(g, radius, width) {
            const outerRadius = radius + width/2;
            const areaTotal = Math.PI * outerRadius * outerRadius; // √Årea total
            const islandRadius = radius - width/2;
            const areaIsla = Math.PI * islandRadius * islandRadius; // √Årea isla
            const areaCarretera = areaTotal - areaIsla; // √Årea solo carretera
            
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 160;
            const ctx = canvas.getContext('2d');
            
            // Fondo semitransparente
            ctx.fillStyle = 'rgba(0,0,0,0.75)';
            ctx.fillRect(0, 0, 512, 160);
            
            // L√≠nea 1: Radio y di√°metro
            ctx.fillStyle = '#60a5fa';
            ctx.font = 'bold 26px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`Radio: ${radius}m | ‚åÄ${radius * 2}m`, 256, 35);
            
            // L√≠nea 2: √Årea total
            ctx.fillStyle = '#22c55e';
            ctx.font = 'bold 24px Arial';
            ctx.fillText(`√Årea Total: ${areaTotal.toFixed(0)} m¬≤`, 256, 75);
            
            // L√≠nea 3: √Årea carretera
            ctx.fillStyle = '#888';
            ctx.font = '20px Arial';
            ctx.fillText(`Carretera: ${areaCarretera.toFixed(0)} m¬≤ | Isla: ${areaIsla.toFixed(0)} m¬≤`, 256, 115);
            
            // L√≠nea 4: Escala maqueta
            ctx.fillStyle = '#666';
            ctx.font = '16px Arial';
            const maqueta = ((radius * 2) / 3).toFixed(1); // Escala 1:300
            ctx.fillText(`Maqueta 1:300: ‚åÄ${maqueta}cm`, 256, 145);
            
            const tex = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: tex });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.position.set(0, 12, 0);
            sprite.scale.set(30, 9, 1);
            sprite.name = 'etiqueta';
            g.add(sprite);
        }

        generateMasterShape() {
            this.objects.forEach(o => this.scene.remove(o));
            this.objects = []; this.select(null);

            const R = 150; const TotalL = 500; const StraightL = TotalL - (R * 2);
            const lS = this.createStraight(StraightL); lS.position.set(-R, 0, 0);
            this.scene.add(lS); this.objects.push(lS);
            const rS = this.createStraight(StraightL); rS.position.set(R, 0, 0);
            this.scene.add(rS); this.objects.push(rS);
            const halfS = StraightL / 2;
            const topCenter = new THREE.Vector3(0, 0, -halfS);
            this.placeCurve(topCenter, 150, 225); this.placeCurve(topCenter, 150, 315);
            const botCenter = new THREE.Vector3(0, 0, halfS);
            this.placeCurve(botCenter, 150, 45); this.placeCurve(botCenter, 150, 135);
            this.camera.position.set(0, 700, 0); this.camera.lookAt(0,0,0);
        }

        placeCurve(pos, rad, rotDeg) {
            const c = this.createCurve(rad, 90); c.position.copy(pos);
            c.rotation.y = rotDeg * (Math.PI/180); this.scene.add(c); this.objects.push(c);
        }

        addStraight() {
            const s = this.createStraight(100); s.position.set(Math.random()*50, 0, Math.random()*50);
            this.scene.add(s); this.objects.push(s); this.select(s);
        }

        addCurve() {
            const c = this.createCurve(50, 90); c.position.set(Math.random()*50, 0, Math.random()*50);
            this.scene.add(c); this.objects.push(c); this.select(c);
        }

        createStraight(len) {
            const g = new THREE.Group(); g.userData = { type: 'straight', length: parseFloat(len), width: 10 };
            this.buildStraight(g); return g;
        }

        createCurve(rad, angle) {
            const g = new THREE.Group(); g.userData = { type: 'curve', radius: parseFloat(rad), angle: angle, width: 10 };
            this.buildCurve(g); return g;
        }

        buildStraight(g) {
            // Limpiar hijos anteriores excepto handles
            const toRemove = g.children.filter(c => !c.userData || !c.userData.isResizeHandle);
            toRemove.forEach(c => {
                if(c.geometry) c.geometry.dispose();
                g.remove(c);
            });
            
            const { length, width } = g.userData;
            const geo = new THREE.PlaneGeometry(width, length);
            const mat = this.selected === g ? this.matSel : this.matRoad;
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = -Math.PI/2; mesh.receiveShadow = true;
            mesh.name = 'roadSurface';
            g.add(mesh);
            
            const cnt = Math.floor(length/10);
            const lGeo = new THREE.PlaneGeometry(0.8, 4);
            const lines = new THREE.InstancedMesh(lGeo, this.matLines, cnt);
            lines.rotation.x = -Math.PI/2; lines.position.y = 0.05;
            lines.name = 'centerLines';
            const dummy = new THREE.Object3D();
            for(let i=0; i<cnt; i++) { dummy.position.set(0, (i - cnt/2 + 0.5)*10, 0); dummy.updateMatrix(); lines.setMatrixAt(i, dummy.matrix); }
            lines.instanceMatrix.needsUpdate = true; g.add(lines);
            
            // Actualizar posici√≥n de handles si existen
            this.updateResizeHandles(g);
        }
        
        // === SISTEMA DE RESIZE HANDLES (ESTILO WORD) ===
        createResizeHandles(roadObj) {
            // Eliminar handles anteriores de este objeto
            this.removeResizeHandles(roadObj);
            
            if(roadObj.userData.type !== 'straight') return;
            
            const { length } = roadObj.userData;
            const handleSize = 3; // Tama√±o del handle en metros
            
            // Handle en extremo positivo (adelante)
            const handleGeoTop = new THREE.SphereGeometry(handleSize, 16, 16);
            const handleTop = new THREE.Mesh(handleGeoTop, this.matHandle);
            handleTop.position.set(0, 1.5, length/2);
            handleTop.userData = { 
                isResizeHandle: true, 
                handleType: 'top', 
                parentRoad: roadObj,
                direction: 1 // Direcci√≥n positiva
            };
            handleTop.name = 'handleTop';
            roadObj.add(handleTop);
            
            // Handle en extremo negativo (atr√°s)
            const handleGeoBot = new THREE.SphereGeometry(handleSize, 16, 16);
            const handleBot = new THREE.Mesh(handleGeoBot, this.matHandle);
            handleBot.position.set(0, 1.5, -length/2);
            handleBot.userData = { 
                isResizeHandle: true, 
                handleType: 'bottom', 
                parentRoad: roadObj,
                direction: -1 // Direcci√≥n negativa
            };
            handleBot.name = 'handleBottom';
            roadObj.add(handleBot);
            
            // Agregar etiqueta de longitud
            this.addRoadLengthLabel(roadObj);
            
            // Registrar handles
            this.resizeHandles.push(handleTop, handleBot);
        }
        
        addRoadLengthLabel(roadObj) {
            // Remover etiqueta anterior si existe
            const oldLabel = roadObj.getObjectByName('lengthLabel');
            if(oldLabel) roadObj.remove(oldLabel);
            
            const { length } = roadObj.userData;
            
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, 256, 64);
            ctx.strokeStyle = '#00aaff';
            ctx.lineWidth = 2;
            ctx.strokeRect(2, 2, 252, 60);
            
            ctx.fillStyle = '#00aaff';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${Math.round(length)}m`, 128, 32);
            
            const tex = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: tex, depthTest: false });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.position.set(0, 8, 0);
            sprite.scale.set(12, 3, 1);
            sprite.name = 'lengthLabel';
            sprite.renderOrder = 999;
            roadObj.add(sprite);
        }
        
        updateRoadLengthLabel(roadObj) {
            const label = roadObj.getObjectByName('lengthLabel');
            if(!label) return;
            
            const { length } = roadObj.userData;
            
            // Recrear textura con nuevo valor
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(0, 0, 256, 64);
            ctx.strokeStyle = '#00aaff';
            ctx.lineWidth = 2;
            ctx.strokeRect(2, 2, 252, 60);
            
            ctx.fillStyle = '#00aaff';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${Math.round(length)}m`, 128, 32);
            
            label.material.map.dispose();
            label.material.map = new THREE.CanvasTexture(canvas);
            label.material.needsUpdate = true;
        }
        
        removeResizeHandles(roadObj) {
            // Remover handles del objeto
            const handlesToRemove = roadObj.children.filter(c => c.userData && c.userData.isResizeHandle);
            handlesToRemove.forEach(h => {
                roadObj.remove(h);
                if(h.geometry) h.geometry.dispose();
                const idx = this.resizeHandles.indexOf(h);
                if(idx > -1) this.resizeHandles.splice(idx, 1);
            });
            
            // Remover etiqueta de longitud
            const label = roadObj.getObjectByName('lengthLabel');
            if(label) {
                roadObj.remove(label);
                label.material.map.dispose();
                label.material.dispose();
            }
        }
        
        updateResizeHandles(roadObj) {
            if(roadObj.userData.type !== 'straight') return;
            
            const { length } = roadObj.userData;
            
            // Buscar handles existentes
            const handleTop = roadObj.children.find(c => c.name === 'handleTop');
            const handleBot = roadObj.children.find(c => c.name === 'handleBottom');
            
            if(handleTop) handleTop.position.z = length/2;
            if(handleBot) handleBot.position.z = -length/2;
        }
        
        hideAllResizeHandles() {
            this.resizeHandles.forEach(h => {
                h.visible = false;
            });
        }
        
        showResizeHandles(roadObj) {
            if(roadObj && roadObj.userData.type === 'straight') {
                // Mostrar solo los handles de este objeto
                roadObj.children.filter(c => c.userData.isResizeHandle).forEach(h => {
                    h.visible = true;
                });
            }
        }

        buildCurve(g) {
            g.children.forEach(c => { if(c.geometry) c.geometry.dispose(); }); g.remove(...g.children);
            const { radius, width, angle } = g.userData; const theta = angle * (Math.PI/180);
            const shape = new THREE.RingGeometry(radius - width/2, radius + width/2, 64, 1, -theta/2, theta);
            const mat = this.selected === g ? this.matSel : this.matRoad;
            const mesh = new THREE.Mesh(shape, mat);
            mesh.rotation.x = -Math.PI/2; mesh.receiveShadow = true; g.add(mesh);
            const lShape = new THREE.RingGeometry(radius - 0.2, radius + 0.2, 64, 1, -theta/2, theta);
            const line = new THREE.Mesh(lShape, this.matLines);
            line.rotation.x = -Math.PI/2; line.position.y = 0.05; g.add(line);
        }

        select(obj) {
            // Ocultar/remover handles del objeto anterior
            if(this.selected && this.selected !== obj) {
                this.updateMat(this.selected, this.matRoad);
                this.removeResizeHandles(this.selected);
            }
            this.selected = obj;
            const panel = document.getElementById('propPanel');
            const cStraight = document.getElementById('controls-straight');
            const cCurve = document.getElementById('controls-curve');

            if(obj) {
                this.updateMat(obj, this.matSel);
                panel.style.display = 'block';
                document.getElementById('rngRot').value = (Math.round(obj.rotation.y * 180/Math.PI)+360)%360;
                document.getElementById('lblRot').innerText = Math.round(obj.rotation.y * 180/Math.PI) + '¬∞';

                if(obj.userData.type === 'straight') {
                    cStraight.style.display = 'block'; cCurve.style.display = 'none';
                    document.getElementById('rngLen').value = obj.userData.length;
                    document.getElementById('lblLen').innerText = Math.round(obj.userData.length)+'m';
                    // Crear handles para resize
                    this.createResizeHandles(obj);
                } else if(obj.userData.type === 'octagon') {
                    // Oct√°gono: mostrar √°rea en lugar de longitud
                    cStraight.style.display = 'block'; cCurve.style.display = 'none';
                    document.getElementById('rngLen').value = obj.userData.area;
                    document.getElementById('lblLen').innerText = Math.round(obj.userData.area)+'m¬≤';
                } else if(obj.userData.type === 'pyramid') {
                    // Pir√°mide: mostrar niveles
                    cStraight.style.display = 'block'; cCurve.style.display = 'none';
                    const totalOcts = obj.userData.levels.reduce((a,b) => a+b, 0);
                    document.getElementById('lblLen').innerText = totalOcts + ' oct√°gonos';
                } else if(obj.userData.type === 'parametricRoundabout') {
                    // Glorieta Param√©trica: mostrar control de di√°metro y √°rea
                    cStraight.style.display = 'none'; 
                    cCurve.style.display = 'none';
                    document.getElementById('controls-roundabout').style.display = 'block';
                    
                    const diametro = obj.userData.diametro;
                    const radio = diametro / 2;
                    const area = Math.PI * radio * radio;
                    const diametroMaqueta = (diametro / 3).toFixed(1);
                    
                    document.getElementById('rngDiam').value = diametro;
                    document.getElementById('lblDiam').innerText = Math.round(diametro)+'m';
                    document.getElementById('lblArea').innerHTML = `√Årea: <strong>${area.toFixed(0)} m¬≤</strong> | Maqueta: ‚åÄ${diametroMaqueta}cm`;
                } else if(obj.userData.type === 'cybertruck') {
                    // Cybertruck: mostrar info del veh√≠culo
                    cStraight.style.display = 'none';
                    cCurve.style.display = 'none';
                    document.getElementById('controls-roundabout').style.display = 'none';
                    
                    // Activar este veh√≠culo para control
                    this.activeVehicle = obj;
                } else {
                    cStraight.style.display = 'none'; cCurve.style.display = 'block';
                    document.getElementById('controls-roundabout').style.display = 'none';
                    document.getElementById('rngRad').value = obj.userData.radius;
                    document.getElementById('lblRad').innerText = Math.round(obj.userData.radius)+'m';
                }
            } else { panel.style.display = 'none'; document.getElementById('controls-roundabout').style.display = 'none'; }
        }

        updateMat(obj, mat) {
            if(obj.userData.type === 'parametricRoundabout') {
                // Glorieta param√©trica: actualizar carretera (child con nombre 'carretera')
                const carretera = obj.getObjectByName('carretera');
                if(carretera) carretera.material = mat;
            } else if(obj.userData.type === 'roundabout') {
                // Glorieta cl√°sica: actualizar carretera por nombre
                const carretera = obj.getObjectByName('carretera');
                if(carretera) carretera.material = mat;
            } else if(obj.userData.type === 'cybertruck') {
                // Cybertruck: mostrar/ocultar highlight
                const hl = obj.getObjectByName('highlight');
                if(hl) hl.visible = (mat === this.matSel);
                // Actualizar color del cuerpo cuando est√° seleccionado
                const body = obj.getObjectByName('body');
                if(body) {
                    if(mat === this.matSel) {
                        body.material = new THREE.MeshStandardMaterial({
                            color: 0x88ccff,
                            roughness: 0.2,
                            metalness: 0.9,
                            emissive: 0x1a3a5c,
                            emissiveIntensity: 0.3
                        });
                    } else {
                        body.material = this.matCyberBody;
                    }
                }
            } else if(obj.userData.type === 'octagon') {
                // Child 0 is walls, tambi√©n mostrar/ocultar highlight
                if(obj.children[0]) obj.children[0].material = mat === this.matSel ? this.matSel : this.matOctWall;
                const hl = obj.getObjectByName('highlight');
                if(hl) hl.visible = (mat === this.matSel);
            } else if(obj.userData.type === 'pyramid') {
                // Pir√°mide: actualizar todos los oct√°gonos hijos
                obj.traverse(child => {
                    if(child.userData && child.userData.type === 'octagon') {
                        if(child.children[0]) child.children[0].material = mat === this.matSel ? this.matSel : this.matOctWall;
                        const hl = child.getObjectByName('highlight');
                        if(hl) hl.visible = (mat === this.matSel);
                    }
                });
            } else {
                if(obj.children[0]) obj.children[0].material = mat;
            }
        }

        setLength(val) {
            if(this.selected && this.selected.userData.type === 'straight') {
                this.selected.userData.length = parseFloat(val);
                document.getElementById('lblLen').innerText = val+'m';
                this.buildStraight(this.selected);
                this.updateResizeHandles(this.selected);
                this.updateRoadLengthLabel(this.selected);
            } else if(this.selected && this.selected.userData.type === 'octagon') {
                // Para oct√°gono, val es el √°rea
                const area = parseFloat(val);
                this.selected.userData.area = area;
                this.selected.userData.radius = Math.sqrt(area / (2 * Math.sqrt(2)));
                document.getElementById('lblLen').innerText = val+'m¬≤'; this.buildOctagon(this.selected);
            }
        }
        setRadius(val) {
            if(this.selected) {
                this.selected.userData.radius = parseFloat(val);
                document.getElementById('lblRad').innerText = val+'m';
                if(this.selected.userData.type === 'roundabout') this.buildRoundabout(this.selected);
                else this.buildCurve(this.selected);
            }
        }
        setRotation(val) {
            if(this.selected) {
                this.selected.rotation.y = val * Math.PI/180;
                document.getElementById('lblRot').innerText = val+'¬∞';
            }
        }
        deleteSelected() {
            if(this.selected) {
                // Si es un veh√≠culo, removerlo de la lista de veh√≠culos
                if(this.selected.userData.type === 'cybertruck') {
                    this.vehicles = this.vehicles.filter(v => v !== this.selected);
                    if(this.activeVehicle === this.selected) {
                        this.activeVehicle = this.vehicles[0] || null;
                    }
                }
                this.scene.remove(this.selected);
                this.objects = this.objects.filter(o => o !== this.selected);
                this.select(null);
            }
        }

        getConnectors(obj) {
            const arr = []; obj.updateMatrixWorld(); const pos = obj.position; const rot = obj.rotation.y;
            if(obj.userData.type === 'straight') {
                const h = obj.userData.length / 2;
                arr.push({ pos: new THREE.Vector3(0,0,-h).applyAxisAngle(new THREE.Vector3(0,1,0), rot).add(pos), dir: new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), rot).normalize() });
                arr.push({ pos: new THREE.Vector3(0,0,h).applyAxisAngle(new THREE.Vector3(0,1,0), rot).add(pos), dir: new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), rot).normalize() });
            } else if (obj.userData.type === 'curve') {
                const R = obj.userData.radius; const halfA = (obj.userData.angle * Math.PI/180) / 2;
                const x1 = R * Math.cos(-halfA); const z1 = -R * Math.sin(-halfA);
                const t1x = Math.sin(-halfA); const t1z = Math.cos(-halfA);
                const p1 = new THREE.Vector3(x1, 0, z1).applyAxisAngle(new THREE.Vector3(0,1,0), rot).add(pos);
                const d1 = new THREE.Vector3(t1x, 0, t1z).applyAxisAngle(new THREE.Vector3(0,1,0), rot).normalize();
                arr.push({ pos: p1, dir: d1 });
                const x2 = R * Math.cos(halfA); const z2 = -R * Math.sin(halfA);
                const t2x = -Math.sin(halfA); const t2z = -Math.cos(halfA);
                const p2 = new THREE.Vector3(x2, 0, z2).applyAxisAngle(new THREE.Vector3(0,1,0), rot).add(pos);
                const d2 = new THREE.Vector3(t2x, 0, t2z).applyAxisAngle(new THREE.Vector3(0,1,0), rot).normalize();
                arr.push({ pos: p2, dir: d2 });
            } else if (obj.userData.type === 'roundabout') {
                // Glorieta cl√°sica: 8 conectores en el borde exterior
                const R = obj.userData.radius + obj.userData.width / 2; // Radio exterior
                for(let i=0; i<8; i++) {
                    const angle = (i * 45) * (Math.PI/180);
                    const lx = Math.cos(angle) * R; const lz = Math.sin(angle) * R;
                    const dx = Math.cos(angle); const dz = Math.sin(angle);
                    const p = new THREE.Vector3(lx, 0, lz).applyAxisAngle(new THREE.Vector3(0,1,0), rot).add(pos);
                    const d = new THREE.Vector3(dx, 0, dz).applyAxisAngle(new THREE.Vector3(0,1,0), rot).normalize();
                    arr.push({ pos: p, dir: d });
                }
            } else if (obj.userData.type === 'parametricRoundabout') {
                // Glorieta param√©trica: 8 conectores en el borde exterior
                const R = obj.userData.diametro / 2 + obj.userData.ancho / 2; // Radio exterior
                for(let i=0; i<8; i++) {
                    const angle = (i * 45) * (Math.PI/180);
                    const lx = Math.cos(angle) * R; const lz = Math.sin(angle) * R;
                    const dx = Math.cos(angle); const dz = Math.sin(angle);
                    const p = new THREE.Vector3(lx, 0, lz).applyAxisAngle(new THREE.Vector3(0,1,0), rot).add(pos);
                    const d = new THREE.Vector3(dx, 0, dz).applyAxisAngle(new THREE.Vector3(0,1,0), rot).normalize();
                    arr.push({ pos: p, dir: d });
                }
            } else if (obj.userData.type === 'octagon') {
                // 8 conectores en los v√©rtices del oct√°gono
                const R = obj.userData.radius;
                for(let i=0; i<8; i++) {
                    const angle = i * (Math.PI * 2 / 8);
                    const lx = Math.cos(angle) * R; const lz = Math.sin(angle) * R;
                    const dx = Math.cos(angle); const dz = Math.sin(angle);
                    const p = new THREE.Vector3(lx, 0, lz).applyAxisAngle(new THREE.Vector3(0,1,0), rot).add(pos);
                    const d = new THREE.Vector3(dx, 0, dz).applyAxisAngle(new THREE.Vector3(0,1,0), rot).normalize();
                    arr.push({ pos: p, dir: d });
                }
            }
            return arr;
        }

        checkSnap() {
            if(!this.selected || !this.isDragging) return;
            const SNAP_DIST = 8; // Distancia de snap reducida (8 metros)
            const myCons = this.getConnectors(this.selected); let snapped = false;
            for(let other of this.objects) {
                if(other === this.selected) continue;
                const otherCons = this.getConnectors(other);
                for(let myC of myCons) {
                    for(let otC of otherCons) {
                        if(myC.pos.distanceTo(otC.pos) < SNAP_DIST) {
                            const offset = new THREE.Vector3().subVectors(myC.pos, this.selected.position);
                            this.selected.position.subVectors(otC.pos, offset);
                            const targetAngle = Math.atan2(otC.dir.x, otC.dir.z) + Math.PI;
                            const currentAngle = Math.atan2(myC.dir.x, myC.dir.z);
                            let delta = targetAngle - currentAngle;
                            this.selected.rotation.y += delta;
                            snapped = true; break;
                        }
                    }
                    if(snapped) break;
                }
                if(snapped) break;
            }
            document.getElementById('snapMsg').style.opacity = snapped ? 1 : 0;
        }

        onDown(e) {
            if(e.button !== 0) return;
            this.mouse.x = (e.clientX/window.innerWidth)*2-1; 
            this.mouse.y = -(e.clientY/window.innerHeight)*2+1;
            this.raycaster.setFromCamera(this.mouse, this.camera);
            
            // Primero verificar si hay clic en un handle de resize
            const handleIntersects = this.raycaster.intersectObjects(this.resizeHandles, false);
            if(handleIntersects.length > 0) {
                const handle = handleIntersects[0].object;
                if(handle.userData.isResizeHandle) {
                    this.isResizing = true;
                    this.activeHandle = handle;
                    this.controls.enabled = false;
                    
                    // Guardar estado inicial para resize
                    const parentRoad = handle.userData.parentRoad;
                    this.resizeStartLength = parentRoad.userData.length;
                    
                    // Posici√≥n mundial del clic
                    const p = new THREE.Vector3();
                    this.raycaster.ray.intersectPlane(this.plane, p);
                    this.resizeStartPos.copy(p);
                    
                    // Cambiar color del handle
                    handle.material = this.matHandleHover;
                    return;
                }
            }
            
            // Si no es un handle, comportamiento normal de arrastre
            const intersects = this.raycaster.intersectObjects(this.objects, true);
            if(intersects.length > 0) {
                let target = intersects[0].object; 
                while(target.parent && target.parent.type !== 'Scene') target = target.parent;
                this.select(target); 
                this.isDragging = true; 
                this.controls.enabled = false;
                const p = new THREE.Vector3(); 
                this.raycaster.ray.intersectPlane(this.plane, p);
                this.dragOffset.subVectors(target.position, p);
            } else { 
                this.select(null); 
            }
        }
        
        onMove(e) {
            this.mouse.x = (e.clientX/window.innerWidth)*2-1; 
            this.mouse.y = -(e.clientY/window.innerHeight)*2+1;
            this.raycaster.setFromCamera(this.mouse, this.camera);
            
            // Modo resize: arrastrar handle
            if(this.isResizing && this.activeHandle) {
                const p = new THREE.Vector3();
                if(this.raycaster.ray.intersectPlane(this.plane, p)) {
                    const parentRoad = this.activeHandle.userData.parentRoad;
                    const direction = this.activeHandle.userData.direction;
                    
                    // Calcular la direcci√≥n de la carretera en espacio mundo
                    const roadAngle = parentRoad.rotation.y;
                    const roadDir = new THREE.Vector3(
                        Math.sin(roadAngle),
                        0,
                        Math.cos(roadAngle)
                    ).normalize();
                    
                    // Calcular delta desde el inicio del resize
                    const delta = new THREE.Vector3().subVectors(p, this.resizeStartPos);
                    
                    // Proyecci√≥n del delta sobre la direcci√≥n de la carretera
                    const projection = delta.dot(roadDir) * direction;
                    
                    // Nueva longitud (m√≠nimo 10m, m√°ximo 500m)
                    // Usamos la proyecci√≥n directa; mover un extremo modifica la longitud en esa misma cantidad.
                    const newLength = Math.max(10, Math.min(500, this.resizeStartLength + projection));
                    
                    // Actualizar longitud
                    parentRoad.userData.length = newLength;
                    this.buildStraight(parentRoad);
                    
                    // Actualizar etiqueta de longitud en tiempo real
                    this.updateRoadLengthLabel(parentRoad);
                    
                    // Actualizar UI
                    document.getElementById('rngLen').value = newLength;
                    document.getElementById('lblLen').innerText = Math.round(newLength) + 'm';
                }
                return;
            }
            
            // Modo hover: destacar handles
            if(!this.isDragging && !this.isResizing) {
                const handleIntersects = this.raycaster.intersectObjects(this.resizeHandles, false);
                this.resizeHandles.forEach(h => {
                    h.material = this.matHandle;
                    h.scale.setScalar(1);
                });
                if(handleIntersects.length > 0) {
                    const handle = handleIntersects[0].object;
                    handle.material = this.matHandleHover;
                    handle.scale.setScalar(1.3);
                    document.body.style.cursor = 'ns-resize';
                } else {
                    document.body.style.cursor = 'default';
                }
            }
            
            // Modo arrastre normal
            if(this.isDragging && this.selected) {
                const p = new THREE.Vector3();
                if(this.raycaster.ray.intersectPlane(this.plane, p)) {
                    this.selected.position.addVectors(p, this.dragOffset); 
                    this.checkSnap();
                }
            }
        }
        
        onUp() { 
            // Finalizar resize
            if(this.isResizing && this.activeHandle) {
                this.activeHandle.material = this.matHandle;
                this.activeHandle = null;
                this.isResizing = false;
            }
            
            this.isDragging = false; 
            this.controls.enabled = true; 
            document.getElementById('snapMsg').style.opacity = 0;
            document.body.style.cursor = 'default';
        }
        onResize() { this.camera.aspect = window.innerWidth/window.innerHeight; this.camera.updateProjectionMatrix(); this.renderer.setSize(window.innerWidth, window.innerHeight); }
        
        onKeyDown(e) {
            // Verificar si hay un veh√≠culo activo para control
            const isVehicle = this.selected && this.selected.userData.type === 'cybertruck';
            
            if(isVehicle) {
                // Control de veh√≠culo
                switch(e.key.toLowerCase()) {
                    case 'w': case 'arrowup':
                        this.vehicleKeys.forward = true;
                        e.preventDefault();
                        return;
                    case 's': case 'arrowdown':
                        this.vehicleKeys.backward = true;
                        e.preventDefault();
                        return;
                    case 'a': case 'arrowleft':
                        this.vehicleKeys.left = true;
                        e.preventDefault();
                        return;
                    case 'd': case 'arrowright':
                        this.vehicleKeys.right = true;
                        e.preventDefault();
                        return;
                    case 'shift':
                        this.vehicleKeys.turbo = true;
                        e.preventDefault();
                        return;
                }
            }
            
            if(!this.selected) return;
            const MOVE_STEP = e.shiftKey ? 10 : 1; // Shift = movimiento r√°pido
            const ROT_STEP = e.shiftKey ? 15 : 5;  // Grados de rotaci√≥n
            
            // Controles est√°ndar para objetos no-veh√≠culo
            if(!isVehicle) {
                switch(e.key) {
                    case 'ArrowUp': case 'w': case 'W':
                        this.selected.position.z -= MOVE_STEP;
                        e.preventDefault();
                        break;
                    case 'ArrowDown': case 's': case 'S':
                        this.selected.position.z += MOVE_STEP;
                        e.preventDefault();
                        break;
                    case 'ArrowLeft': case 'a': case 'A':
                        this.selected.position.x -= MOVE_STEP;
                        e.preventDefault();
                        break;
                    case 'ArrowRight': case 'd': case 'D':
                        this.selected.position.x += MOVE_STEP;
                        e.preventDefault();
                        break;
                }
            }
            
            switch(e.key) {
                case 'q': case 'Q': // Rotar izquierda
                    if(isVehicle) {
                        this.vehicleKeys.left = true;
                    } else {
                        this.selected.rotation.y -= ROT_STEP * Math.PI / 180;
                        this.updateRotationUI();
                    }
                    e.preventDefault();
                    break;
                case 'e': case 'E': // Rotar derecha
                    if(isVehicle) {
                        this.vehicleKeys.right = true;
                    } else {
                        this.selected.rotation.y += ROT_STEP * Math.PI / 180;
                        this.updateRotationUI();
                    }
                    e.preventDefault();
                    break;
                case 'Delete': case 'Backspace':
                    this.deleteSelected();
                    e.preventDefault();
                    break;
                case 'Escape':
                    this.select(null);
                    e.preventDefault();
                    break;
            }
        }
        
        onKeyUp(e) {
            switch(e.key.toLowerCase()) {
                case 'w': case 'arrowup':
                    this.vehicleKeys.forward = false;
                    break;
                case 's': case 'arrowdown':
                    this.vehicleKeys.backward = false;
                    break;
                case 'a': case 'arrowleft':
                    this.vehicleKeys.left = false;
                    break;
                case 'd': case 'arrowright':
                    this.vehicleKeys.right = false;
                    break;
                case 'q':
                    this.vehicleKeys.left = false;
                    break;
                case 'e':
                    this.vehicleKeys.right = false;
                    break;
                case 'shift':
                    this.vehicleKeys.turbo = false;
                    break;
            }
        }
        
        updateRotationUI() {
            if(this.selected) {
                const deg = Math.round((this.selected.rotation.y * 180 / Math.PI + 360) % 360);
                document.getElementById('rngRot').value = deg;
                document.getElementById('lblRot').innerText = deg + '¬∞';
            }
        }
        
        animate() { 
            requestAnimationFrame(() => this.animate()); 
            
            // Calcular delta time para f√≠sica
            const deltaTime = Math.min(this.clock.getDelta(), 0.1); // Cap a 100ms
            
            // Actualizar f√≠sica de veh√≠culos
            this.updateVehicles(deltaTime);
            
            this.controls.update(); 
            this.renderer.render(this.scene, this.camera); 
        }

        exportDXF() {
            // === HEADER SECTION ===
            let s = "0\nSECTION\n2\nHEADER\n";
            s += "9\n$ACADVER\n1\nAC1015\n"; // AutoCAD 2000
            s += "9\n$INSUNITS\n70\n6\n";    // Unidades: metros
            s += "0\nENDSEC\n";
            
            // === TABLES SECTION (capas) ===
            s += "0\nSECTION\n2\nTABLES\n";
            s += "0\nTABLE\n2\nLAYER\n70\n10\n";
            const layers = ['Road', 'RoadCenter', 'Roundabout', 'RoundaboutCenter', 'RoadCurve', 'RoadCurveCenter', 
                           'COLUMNAS', 'BORDES', 'TECHOS', 'PISOS', 'Octagon', 'Pyramid', 'BaseArea', 'Cybertruck'];
            const colors = [7, 1, 3, 1, 4, 1, 2, 5, 6, 30, 140, 200, 8, 150];
            layers.forEach((name, i) => {
                s += `0\nLAYER\n2\n${name}\n70\n0\n62\n${colors[i]}\n6\nCONTINUOUS\n`;
            });
            s += "0\nENDTAB\n0\nENDSEC\n";
            
            // === ENTITIES SECTION ===
            s += "0\nSECTION\n2\nENTITIES\n";
            
            this.objects.forEach(o => {
                const p = o.position, r = o.rotation.y;
                
                if(o.userData.type === 'straight') {
                    const h = o.userData.length / 2;
                    const w = o.userData.width / 2;
                    const dirX = Math.sin(r), dirZ = Math.cos(r);
                    const perpX = Math.cos(r), perpZ = -Math.sin(r);
                    
                    const corners = [
                        { x: p.x - dirX*h - perpX*w, z: p.z - dirZ*h - perpZ*w },
                        { x: p.x + dirX*h - perpX*w, z: p.z + dirZ*h - perpZ*w },
                        { x: p.x + dirX*h + perpX*w, z: p.z + dirZ*h + perpZ*w },
                        { x: p.x - dirX*h + perpX*w, z: p.z - dirZ*h + perpZ*w }
                    ];
                    
                    for(let i = 0; i < 4; i++) {
                        const c1 = corners[i], c2 = corners[(i + 1) % 4];
                        s += `0\nLINE\n8\nRoad\n10\n${c1.x.toFixed(4)}\n20\n${c1.z.toFixed(4)}\n30\n0.0\n11\n${c2.x.toFixed(4)}\n21\n${c2.z.toFixed(4)}\n31\n0.0\n`;
                    }
                    
                    const x1 = p.x - dirX*h, z1 = p.z - dirZ*h;
                    const x2 = p.x + dirX*h, z2 = p.z + dirZ*h;
                    s += `0\nLINE\n8\nRoadCenter\n10\n${x1.toFixed(4)}\n20\n${z1.toFixed(4)}\n30\n0.0\n11\n${x2.toFixed(4)}\n21\n${z2.toFixed(4)}\n31\n0.0\n`;
                    
                } else if(o.userData.type === 'roundabout') {
                    const R = o.userData.radius;
                    const w = o.userData.width / 2;
                    s += `0\nCIRCLE\n8\nRoundabout\n10\n${p.x.toFixed(4)}\n20\n${p.z.toFixed(4)}\n30\n0.0\n40\n${(R - w).toFixed(4)}\n`;
                    s += `0\nCIRCLE\n8\nRoundabout\n10\n${p.x.toFixed(4)}\n20\n${p.z.toFixed(4)}\n30\n0.0\n40\n${(R + w).toFixed(4)}\n`;
                    s += `0\nCIRCLE\n8\nRoundaboutCenter\n10\n${p.x.toFixed(4)}\n20\n${p.z.toFixed(4)}\n30\n0.0\n40\n${R.toFixed(4)}\n`;
                    
                } else if(o.userData.type === 'octagon') {
                    const R = o.userData.radius;
                    const h = o.userData.height / 2;
                    const vB = [], vT = [];
                    for(let i = 0; i < 8; i++) {
                        const a = i * (Math.PI * 2 / 8) + r;
                        const vx = Math.cos(a) * R;
                        const vz = Math.sin(a) * R;
                        vB.push({x: p.x + vx, y: p.y - h, z: p.z + vz});
                        vT.push({x: p.x + vx, y: p.y + h, z: p.z + vz});
                    }
                    for(let i = 0; i < 8; i++) {
                        const n = (i + 1) % 8;
                        // Columnas verticales
                        s += `0\nLINE\n8\nCOLUMNAS\n10\n${vB[i].x.toFixed(4)}\n20\n${vB[i].z.toFixed(4)}\n30\n${vB[i].y.toFixed(4)}\n11\n${vT[i].x.toFixed(4)}\n21\n${vT[i].z.toFixed(4)}\n31\n${vT[i].y.toFixed(4)}\n`;
                        // Bordes base
                        s += `0\nLINE\n8\nBORDES\n10\n${vB[i].x.toFixed(4)}\n20\n${vB[i].z.toFixed(4)}\n30\n${vB[i].y.toFixed(4)}\n11\n${vB[n].x.toFixed(4)}\n21\n${vB[n].z.toFixed(4)}\n31\n${vB[n].y.toFixed(4)}\n`;
                        // Bordes techo
                        s += `0\nLINE\n8\nBORDES\n10\n${vT[i].x.toFixed(4)}\n20\n${vT[i].z.toFixed(4)}\n30\n${vT[i].y.toFixed(4)}\n11\n${vT[n].x.toFixed(4)}\n21\n${vT[n].z.toFixed(4)}\n31\n${vT[n].y.toFixed(4)}\n`;
                    }
                    
                } else if(o.userData.type === 'pyramid') {
                    // Exportar pir√°mide: cada oct√°gono en su posici√≥n
                    const basePos = o.position;
                    o.children.forEach(child => {
                        if(child.userData && child.userData.type === 'octagon') {
                            const cp = child.position;
                            const R = child.userData.radius;
                            const h = child.userData.height / 2;
                            const worldX = basePos.x + cp.x;
                            const worldY = basePos.y + cp.y;
                            const worldZ = basePos.z + cp.z;
                            
                            const vB = [], vT = [];
                            for(let i = 0; i < 8; i++) {
                                const a = i * (Math.PI * 2 / 8) + r;
                                const vx = Math.cos(a) * R;
                                const vz = Math.sin(a) * R;
                                vB.push({x: worldX + vx, y: worldY - h, z: worldZ + vz});
                                vT.push({x: worldX + vx, y: worldY + h, z: worldZ + vz});
                            }
                            for(let i = 0; i < 8; i++) {
                                const n = (i + 1) % 8;
                                s += `0\nLINE\n8\nPyramid\n10\n${vB[i].x.toFixed(4)}\n20\n${vB[i].z.toFixed(4)}\n30\n${vB[i].y.toFixed(4)}\n11\n${vT[i].x.toFixed(4)}\n21\n${vT[i].z.toFixed(4)}\n31\n${vT[i].y.toFixed(4)}\n`;
                                s += `0\nLINE\n8\nPyramid\n10\n${vB[i].x.toFixed(4)}\n20\n${vB[i].z.toFixed(4)}\n30\n${vB[i].y.toFixed(4)}\n11\n${vB[n].x.toFixed(4)}\n21\n${vB[n].z.toFixed(4)}\n31\n${vB[n].y.toFixed(4)}\n`;
                                s += `0\nLINE\n8\nPyramid\n10\n${vT[i].x.toFixed(4)}\n20\n${vT[i].z.toFixed(4)}\n30\n${vT[i].y.toFixed(4)}\n11\n${vT[n].x.toFixed(4)}\n21\n${vT[n].z.toFixed(4)}\n31\n${vT[n].y.toFixed(4)}\n`;
                            }
                        }
                    });
                    
                } else if(o.userData.type === 'parametricRoundabout') {
                    // Glorieta Param√©trica: igual que roundabout pero usa diametro
                    const diametro = o.userData.diametro;
                    const R = diametro / 2;
                    const w = o.userData.ancho / 2;
                    s += `0\nCIRCLE\n8\nRoundabout\n10\n${p.x.toFixed(4)}\n20\n${p.z.toFixed(4)}\n30\n0.0\n40\n${(R - w).toFixed(4)}\n`;
                    s += `0\nCIRCLE\n8\nRoundabout\n10\n${p.x.toFixed(4)}\n20\n${p.z.toFixed(4)}\n30\n0.0\n40\n${(R + w).toFixed(4)}\n`;
                    s += `0\nCIRCLE\n8\nRoundaboutCenter\n10\n${p.x.toFixed(4)}\n20\n${p.z.toFixed(4)}\n30\n0.0\n40\n${R.toFixed(4)}\n`;
                    
                } else if(o.userData.type === 'curve') {
                    const R = o.userData.radius;
                    const w = o.userData.width / 2;
                    const startDeg = ((r * 180/Math.PI) - (o.userData.angle/2) - 90);
                    const endDeg = ((r * 180/Math.PI) + (o.userData.angle/2) - 90);
                    s += `0\nARC\n8\nRoadCurve\n10\n${p.x.toFixed(4)}\n20\n${p.z.toFixed(4)}\n30\n0.0\n40\n${(R - w).toFixed(4)}\n50\n${startDeg.toFixed(4)}\n51\n${endDeg.toFixed(4)}\n`;
                    s += `0\nARC\n8\nRoadCurve\n10\n${p.x.toFixed(4)}\n20\n${p.z.toFixed(4)}\n30\n0.0\n40\n${(R + w).toFixed(4)}\n50\n${startDeg.toFixed(4)}\n51\n${endDeg.toFixed(4)}\n`;
                    s += `0\nARC\n8\nRoadCurveCenter\n10\n${p.x.toFixed(4)}\n20\n${p.z.toFixed(4)}\n30\n0.0\n40\n${R.toFixed(4)}\n50\n${startDeg.toFixed(4)}\n51\n${endDeg.toFixed(4)}\n`;
                    
                } else if(o.userData.type === 'baseArea') {
                    // Exportar el √°rea base como rect√°ngulo
                    const w = o.userData.width / 2;
                    const d = o.userData.depth / 2;
                    const corners = [
                        {x: p.x - w, z: p.z - d},
                        {x: p.x + w, z: p.z - d},
                        {x: p.x + w, z: p.z + d},
                        {x: p.x - w, z: p.z + d}
                    ];
                    for(let i = 0; i < 4; i++) {
                        const c1 = corners[i], c2 = corners[(i + 1) % 4];
                        s += `0\nLINE\n8\nBaseArea\n10\n${c1.x.toFixed(4)}\n20\n${c1.z.toFixed(4)}\n30\n0.0\n11\n${c2.x.toFixed(4)}\n21\n${c2.z.toFixed(4)}\n31\n0.0\n`;
                    }
                } else if(o.userData.type === 'cybertruck') {
                    // Exportar Cybertruck como rect√°ngulo con orientaci√≥n
                    const L = o.userData.length;
                    const W = o.userData.width;
                    const hL = L / 2;
                    const hW = W / 2;
                    
                    // Calcular esquinas rotadas
                    const cos = Math.cos(r);
                    const sin = Math.sin(r);
                    const corners = [
                        { x: p.x + (-hL * cos - (-hW) * sin), z: p.z + (-hL * sin + (-hW) * cos) },
                        { x: p.x + (hL * cos - (-hW) * sin), z: p.z + (hL * sin + (-hW) * cos) },
                        { x: p.x + (hL * cos - hW * sin), z: p.z + (hL * sin + hW * cos) },
                        { x: p.x + (-hL * cos - hW * sin), z: p.z + (-hL * sin + hW * cos) }
                    ];
                    
                    // Dibujar contorno
                    for(let i = 0; i < 4; i++) {
                        const c1 = corners[i], c2 = corners[(i + 1) % 4];
                        s += `0\nLINE\n8\nCybertruck\n10\n${c1.x.toFixed(4)}\n20\n${c1.z.toFixed(4)}\n30\n0.0\n11\n${c2.x.toFixed(4)}\n21\n${c2.z.toFixed(4)}\n31\n0.0\n`;
                    }
                    
                    // Dibujar l√≠nea central (direcci√≥n)
                    const frontX = p.x - hL * sin;
                    const frontZ = p.z - hL * cos;
                    const backX = p.x + hL * sin;
                    const backZ = p.z + hL * cos;
                    s += `0\nLINE\n8\nCybertruck\n10\n${frontX.toFixed(4)}\n20\n${frontZ.toFixed(4)}\n30\n0.0\n11\n${backX.toFixed(4)}\n21\n${backZ.toFixed(4)}\n31\n0.0\n`;
                    
                    // Dibujar ruedas como c√≠rculos peque√±os
                    const wheelRadius = 0.45;
                    const wb = o.userData.wheelbase;
                    const wheelPositions = [
                        { x: -wb/2 + 0.3, z: hW - 0.45 },
                        { x: -wb/2 + 0.3, z: -hW + 0.45 },
                        { x: wb/2 - 0.3, z: hW - 0.45 },
                        { x: wb/2 - 0.3, z: -hW + 0.45 }
                    ];
                    wheelPositions.forEach(wp => {
                        const wx = p.x + (wp.x * cos - wp.z * sin);
                        const wz = p.z + (wp.x * sin + wp.z * cos);
                        s += `0\nCIRCLE\n8\nCybertruck\n10\n${wx.toFixed(4)}\n20\n${wz.toFixed(4)}\n30\n0.0\n40\n${wheelRadius.toFixed(4)}\n`;
                    });
                }
            });
            
            s += "0\nENDSEC\n0\nEOF\n";
            const b = new Blob([s], {type: 'application/dxf'});
            const l = document.createElement('a'); 
            l.href = URL.createObjectURL(b); 
            l.download = 'piramides_1_300.dxf'; 
            l.click();
        }
    }

    window.editor = new RoadEditor();
</script>
</body>
</html>